<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Testing - GoLedger CC-Tools</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Testing";
    var mkdocs_page_input_path = "testing.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> GoLedger CC-Tools</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../getting-started/">Getting Started</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../tutorials/">Tutorials</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../assets/">Assets</a>
                    </li>
                </ul>
                <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../datatypes/">Datatypes</a>
                  </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../transactions/">Transactions</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../external-tools/">External Tools</a>
                    </li>
                </ul>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Testing</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#using-cc-webclient">Using cc-webclient</a>
        <ul>
            <li class="toctree-l3"><a class="reference internal" href="#configuring-rest-server-and-cc-webclient">Configuring rest-server and cc-webclient</a>
            </li>
            <li class="toctree-l3"><a class="reference internal" href="#endpoint-usage">Endpoint usage</a>
            </li>
            <li class="toctree-l3"><a class="reference internal" href="#list-create-edit-delete-or-history-an-asset">List, create, edit, delete or history an asset</a>
            </li>
            <li class="toctree-l3"><a class="reference internal" href="#executing-an-transaction">Executing an transaction</a>
            </li>
        </ul>
    </li>

    <li class="toctree-l2"><a class="reference internal" href="#using-godog">Using Godog</a>
        <ul>
            <li class="toctree-l3"><a class="reference internal" href="#feature-definition">Feature definition</a>
            </li>
            <li class="toctree-l3"><a class="reference internal" href="#feature-examples">Feature examples</a>
            </li>
            <li class="toctree-l3"><a class="reference internal" href="#implementation-steps">Implementation of steps</a>
            </li>
            <li class="toctree-l3"><a class="reference internal" href="#run-godog-tests">Run godog tests</a>
            </li>        
        </ul>
    </li>
    </ul>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">GoLedger CC-Tools</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Testing</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="testing">Testing</h1>
<p><strong>GoLedger CC-Tools</strong> has different ways for testing the source code in development mode.</p>
<p>For <strong>GoLang</strong> syntax checking, execute the following command:</p>
<pre><code class="language-sh">cd chaincode \
go vet
</code></pre>
<p>After the succesfull code instantiation or update, you can check the logs directly inside the <strong>chaincode</strong> execution <strong>peers</strong> containers. These containers can be identified by starting with <code>dev</code>.</p>
<pre><code class="language-sh">docker logs dev-peer0.org1.example.com-cc-tools-demo-0.1
</code></pre>
<h2 id="using-cc-webclient">Using cc-webclient</h2>
<p>To perform the tests and integrations satisfactorily, it is suggested the usage of <strong>cc-webclient</strong> tool. After finishing the steps, it is suggested to execute the following commands to create 3 applications in order to connect with <strong>org1, org2 and org3</strong>.</p>
<pre><code class="language-sh">./run-cc-web.sh 8080 &amp; \
./run-cc-web.sh 8090 &amp; \
./run-cc-web.sh 8100 &amp;
</code></pre>
<h3 id="configuring-rest-server-and-cc-webclient">Configuring rest-server and cc-webclient</h3>
<p>After executing <strong>cc-webclient</strong> containers, the applications can be accessed directly through the ports defined in the script. E.g.: 8080, 8090, 8100</p>
<p>After accessing <strong>cc-webclient</strong> through the browser, the configuration of rest server address can be done by clicking on the tool icon.</p>
<p><img alt="Config" src="../img/header-cc-webclient.png" /></p>
<p>Accesses are can be made with the following settings:</p>
<ul>
<li><code>org1</code>: <strong>http://localhost:80</strong></li>
<li><code>org2</code>: <strong>http://localhost:980</strong></li>
<li><code>org3</code>: <strong>http://localhost:1080</strong></li>
</ul>
<p><img alt="Config" src="../img/config-cc-webclient.png" /></p>
<p><strong>cc-webclient</strong> application has a sidebar that shows the available <strong>assets</strong> as well as the <strong>transactions</strong> registered in the chaincode.</p>
<p><img alt="Bar" src="../img/bar-cc-webclient.png" /></p>
<h3 id="endpoint-usage">Endpoint usage</h3>
<p>The rest-server endpoint usage is shown using the <strong>CURL</strong> buttons.</p>
<p><img alt="CURL" src="../img/curl-cc-webclient.png" /></p>
<p>For each screen, you can check endpoint usage pressing the <code>curl</code> button.</p>
<p>For example, on the asset creation screen:</p>
<p><img alt="CURL" src="../img/curl-create-cc-webclient.png" /></p>
<h3 id="list-create-edit-delete-or-history-an-asset">List, create, edit, delete or history an asset</h3>
<p>To <strong>list</strong> each asset, just select an asset in the sidebar.</p>
<p><img alt="List Asset" src="../img/list-cc-webclient.png" /></p>
<p>Selecting the <code>CREATE</code> button at the asset list window, an asset <strong>creation</strong> screen will appear.</p>
<p>For example, for the <strong>Person</strong> asset</p>
<p><img alt="Create Asset" src="../img/create-asset-cc-webclient.png" /></p>
<p>The <strong>edit</strong> screen is accessed by selecting the <strong>edit icon</strong> in an asset's list window.</p>
<p>The <strong>removal</strong> of an asset is requested by selecting the <strong>delete icon</strong> in the asset's list window.</p>
<p>The <strong>history</strong> of an asset (all changes recorded in the ledger) can be viewed by selecting the <strong>history icon</strong> in an asset's window.</p>
<h3 id="executing-an-transaction">Executing an transaction</h3>
<p>The <strong>transaction</strong> execution can be performed by selecting the transaction in the sidebar.</p>
<p>For example, for transaction <strong>UpdateBookTenant</strong></p>
<p><img alt="Transaction" src="../img/transaction-cc-webclient.png" /></p>

<h2 id="using-godog">Using Godog</h2>
<p><code>Godog</code> is the official Cucumber BDD framework for Golang. It follows the principles of BDD, which emphasizes defining the desired behavior of the software through user-focused scenarios written in natural language. These scenarios are written in a Given-When-Then format, making it easier for non-technical team members to understand and contribute to the testing process.</p>

<p>For the cc-tools-demo repository, there are godog tests for every transaction. Each transaction is represented as a feature and each feature has scenarios to be tested.</p>

<p>Features are defined in <code>chaincode/tests/features</code> folder.</p>
<pre><code>chaincode/
  tests/
    features/
      createNewLibrary.feature              # definition of Create New Library feature
      getBooksByAuthor.feature              # definition of Get Books By Author feature
      getNumberOfBooksFromLibrary.feature   # definition of Get Number Of Books From Library feature
      updateBookTenant.feature              # definition of Create New Library feature
    request_test.go                         # implementation of steps for scenarios
</code></pre>


<h3 id="feature-definition">Feature definition</h3>
<p>In the feature file, you start by defining the <strong>feature</strong> using the <code>Feature</code> keyword followed by a brief description. Each <strong>scenario</strong> within the feature is defined using the <code>Scenario</code> keyword, followed by a scenario title or description. Scenarios represent specific use cases or situations that you want to test. Inside each scenario, you define the <strong>steps</strong> of the test using <code>Given</code>, <code>When</code>, and <code>Then</code> keywords. These steps describe the preconditions (Given), actions (When), and expected outcomes (Then) of the scenario. Optionally, you can also use <code>And</code> and <code>But</code> to further clarify or add additional steps.</p>
<p>See more on <a href="https://github.com/cucumber/godog">Godog/Cucumber</a>.</p>

<h3 id="feature-examples">Feature examples</h3>
The definition of <strong>Create New Library</strong> feature is as follows:
<pre><code>Feature: Create New Library
  In order to create a new library
  As an API client
  I want to make a request with the name of the desired library

  Scenario: Create a new library
      Given there is a running "" test network from scratch
      When I make a "POST" request to "/api/invoke/createNewLibrary" on port 880 with:
          """
          {
              "name": "Elizabeth's Library"
          }
          """
      Then the response code should be 200
      And the response should have:
          """
          {
              "@key":         "library:9cf6726a-a327-568a-baf1-5881393073bf",
              "@lastTouchBy": "orgMSP",
              "@lastTx":      "createNewLibrary",
              "@assetType":   "library",
              "name":         "Elizabeth's Library"
          }
          """

  Scenario: Try to create a new library with a name that already exists
      Given there is a running "" test network
      Given there is a library with name "John's Library"
      When I make a "POST" request to "/api/invoke/createNewLibrary" on port 880 with:
          """
          {
              "name": "John's Library"
          }
          """
      Then the response code should be 409
</code></pre>

<p>This feature tests the ability to create a new library using the <code>createNewLibrary</code> tx through the API. It consists of two scenarios: one is a successful case, and the other tests when attempting to create a library with a name that already exists.</p>
<ul>
  <li><strong>Scenario 1:</strong> This scenario represents the successful creation of a new library. It verifies that the API can correctly handle the request with a new library name and returns the expected response.</li>
  <li><strong>Scenario 2:</strong> This scenario tests the case when attempting to create a library with a name that already exists in the system. It checks whether the API responds with the appropriate status code (409) to indicate a conflict.</li>
</ul>
<p>The definition of <strong>Get Books By Author</strong> feature is as follows:</p>
<pre><code>Feature: Get Books By Author
  In order to get all the books by an author
  As an API client
  I want to make a request to the getBooksByAuthor transaction
  And receive the appropriate books

  Scenario: Request an author with multiple books
      Given there is a running "" test network
      And there are 3 books with prefix "book" by author "Jack"
      When I make a "GET" request to "/api/query/getBooksByAuthor" on port 880 with:
          """
          {
              "authorName": "Jack"
          }
          """
      Then the response code should be 200
      And the "result" field should have size 3

  Scenario: Request an author with no books
      Given there is a running "" test network
      When I make a "GET" request to "/api/query/getBooksByAuthor" on port 880 with:
          """
          {
              "authorName": "Mary"
          }
          """
      Then the response code should be 200
      And the "result" field should have size 0

  Scenario: Request an author with 2 books while there are other authors with more books
      Given there is a running "" test network
      Given there are 1 books with prefix "fantasy" by author "Missy"
      Given there are 2 books with prefix "cook" by author "John"
      When I make a "GET" request to "/api/query/getBooksByAuthor" on port 880 with:
          """
          {
              "authorName": "John"
          }
          """
      Then the response code should be 200
      And the "result" field should have size 2
</code></pre>

<p>This feature tests the ability to retrieve books written by a specific author using the <code>getBooksByAuthor</code> transaction through the API. It consists of three scenarios that cover different cases based on the number of books by the requested author.</p>
<ul>
  <li><strong>Scenario 1:</strong> This scenario verifies that the API can successfully handle a request for an author who has multiple books in the system. It checks whether the API returns the correct response code (200) and that the "result" field in the response contains all the books by the author with a size of 3.</li>
  <li><strong>Scenario 2:</strong> This scenario tests the case when requesting an author who has no books in the system. It checks whether the API returns the appropriate response code (200) and that the "result" field in the response is empty with a size of 0.</li>
  <li><strong>Scenario 3:</strong> This scenario validates the API's response when requesting an author with two books, while other authors have more books in the system. It verifies whether the API returns the correct response code (200) and that the "result" field contains the two books by the requested author with a size of 2.</li>
</ul>

<p>The definition of <strong>Get Number Of Books From Library</strong> feature is as follows:</p>
<pre><code>Feature: Get Number Of Books From Library
  In order to create the number of books from library
  As an API client
  I want to make a request

  Scenario: Query Get Number Of Books From Library that Exists
      Given there is a running "" test network
      And I make a "POST" request to "/api/invoke/createAsset" on port 880 with:
          """
          {
              "asset": [
                  {
                      "@assetType": "book",
                      "title":      "Meu Nome é Maria",
                      "author":     "Maria Viana"
                  }
              ]
          }
          """
      And I make a "POST" request to "/api/invoke/createAsset" on port 880 with:
          """
          {
              "asset": [{
                  "@assetType": "library",
                  "name": "Maria's Library",
                  "books": [
                      {
                          "@assetType": "book",
                          "@key": "book:a36a2920-c405-51c3-b584-dcd758338cb5"
                      }
                  ]
              }]
        }
          """
      When I make a "GET" request to "/api/query/getNumberOfBooksFromLibrary" on port 880 with:
          """
          {
              "library": {
                  "@key": "library:3cab201f-9e2b-579d-b7b2-72297ed17f49",
                  "@assetType": "library"
          }
          }
          """
      Then the response code should be 200
      And the response should have:
          """
          {
              "numberOfBooks": 1.0
          }
          """

  Scenario: Query Get Number Of Books From Library that Does Not Exists
      Given there is a running "" test network
      When I make a "GET" request to "/api/query/getNumberOfBooksFromLibrary" on port 880 with:
          """
          {
              "library": {
                  "@key": "library:5c5b201f-9e4c-579d-b7b2-72297ed17f78",
                  "@assetType": "library"
          }
          }
          """
      Then the response code should be 400
</code></pre>
<p>This feature tests the ability to retrieve the number of books from a library through the API. It consists of two scenarios: one scenario deals with querying a library that exists and has books, while the other scenario tests querying a library that does not exist.</p>
<ul>
  <li><strong>Scenario 1:</strong> This scenario verifies that the API can successfully retrieve the number of books from a library that exists in the system. It first creates a new book and a library with the book associated. Then it queries the number of books from the library and checks whether the API returns the correct response code (200) and whether the response contains the expected number of books (1).</li>
  <li><strong>Scenario 2:</strong> This scenario tests the case when attempting to query the number of books from a library that does not exist in the system. It checks whether the API returns the appropriate response code (400) to indicate a bad request due to the non-existent library.</li>
</ul>

<p>The definition of <strong>Update Book Tentant</strong> feature is as follows:</p>
<pre><code>Feature: Update Book Tentant
  In order to update book tentant
  As an API client
  I want to make a request

  Scenario: Update Book With A Existing Tentant 
      # The first 3 statements will be used by all scenarios on this feature
      Given there is a running "" test network
      And I make a "POST" request to "/api/invoke/createAsset" on port 880 with:
          """
          {
              "asset": [{
                      "@assetType": "book",
                      "title":      "Meu Nome é Maria",
                      "author":     "Maria Viana"
                  }]
          }
          """
      And I make a "POST" request to "/api/invoke/createAsset" on port 880 with:
          """
         {
              "asset": [{
                  "@assetType": "person",
                  "name": "Maria",
                  "id": "31820792048"
              }]
        }
          """
      When I make a "PUT" request to "/api/invoke/updateBookTenant" on port 880 with:
          """
          {
              "book": {
                  "@assetType": "book",
                  "@key": "book:a36a2920-c405-51c3-b584-dcd758338cb5"
          },
              "tenant": {
                  "@assetType": "person",
                  "@key": "person:47061146-c642-51a1-844a-bf0b17cb5e19"
              }
          }
          """
      Then the response code should be 200
      And the response should have:
          """
          {
              "@key": "book:a36a2920-c405-51c3-b584-dcd758338cb5",
              "@lastTouchBy": "orgMSP",
              "@lastTx": "updateBookTenant",
              "currentTenant": {
            "@assetType": "person",
            "@key": "person:47061146-c642-51a1-844a-bf0b17cb5e19"
          }
          }
          """

  Scenario: Update Book With A Not Existing Tentant
      Given there is a running "" test network
      When I make a "PUT" request to "/api/invoke/updateBookTenant" on port 880 with:
          """
          {
              "book": {
                  "@assetType": "book",
                  "@key": "book:a36a2920-c405-51c3-b584-dcd758338cb5"
          },
              "tenant": {
                  "@assetType": "person",
                  "@key": "person:56891146-c6866-51a1-844a-bf0b17cb5e19"
              }
          }
          """
      Then the response code should be 404
</code></pre>
<p>This feature tests the ability to update the tenant of a book using the API. It consists of two scenarios: one scenario deals with updating a book with an existing tenant, and the other scenario tests updating a book with a non-existent tenant.</p>
<ul>
  <li><strong>Scenario 1:</strong> This scenario verifies that the API can successfully update the tenant of a book with an existing tenant. It creates a new book and a new person (tenant), associates the person with the book, and then makes a PUT request to update the book's tenant. The scenario checks whether the API returns the correct response code (200) and whether the book's tenant is correctly updated in the response.</li>
  <li><strong>Scenario 2:</strong> This scenario tests the case when attempting to update the tenant of a book with a tenant that does not exist in the system. It makes a PUT request to update the book's tenant with the non-existing tenant. The scenario checks whether the API returns the appropriate response code (404) to indicate that the tenant does not exist in the system.</li>
</ul>

<h3 id="implementation-steps">Implementation of steps</h3>
<p>Each step is implemented in <code>chaincode/tests/request_test.go</code> file.</p>

<p>For <code>Given there is a running "" test network from scratch</code> there is the following implementation:</p>
<pre><code>func thereIsARunningTestNetworkFromScratch(arg1 string) error {
	// Start test network with 1 org only
	cmd := exec.Command("../../startDev.sh", "-n", "1")

	_, err := cmd.Output()

	if err != nil {
		fmt.Println(err.Error())
		return err
	}

	// Wait for ccapi
	err = waitForNetwork("880")
	if err != nil {
		fmt.Println(err.Error())
		return err
	}

	return nil
}  
</code></pre>
<p>This function starts a test network from scratch with a single organization. It executes a shell command <code>../../startDev.sh -n 1</code> to start the test network. After starting the network, it waits for the ccapi to be available on port 880 using the <code>waitForNetwork</code> function.</p>

<p>For <code>When I make a "[method]" request to "[endpoint]" on port [port] with "[body]"</code> there is the following implementation:</p>
<pre><code>func iMakeARequestToOnPortWith(ctx context.Context, method, endpoint string, port int, reqBody *godog.DocString) (context.Context, error) {
	var res *http.Response
	var req *http.Request
	var err error

	// Initialize http client
	client := &http.Client{}

	// Create request
	if method == "GET" {
		b64str := b64.StdEncoding.EncodeToString([]byte(reqBody.Content))
		reqParam := "?@request=" + b64str
		req, err = http.NewRequest("GET", "http://localhost:"+strconv.Itoa(port)+endpoint+reqParam, nil)
		if err != nil {
			return ctx, err
		}
	} else {
		dataAsBytes := bytes.NewBuffer([]byte(reqBody.Content))

		req, err = http.NewRequest(method, "http://localhost:"+strconv.Itoa(port)+endpoint, dataAsBytes)
		if err != nil {
			return ctx, err
		}
	}

	// Set header and make request
	req.Header.Set("Content-Type", "application/json")
	res, err = client.Do(req)
	if err != nil {
		return ctx, err
	}

	// Get status code and response body
	statusCode := res.StatusCode
	resBody, err := ioutil.ReadAll(res.Body)

	if err != nil {
		return ctx, err
	}
	res.Body.Close()

	// Append status code and response body to context
	bodyCtx := context.WithValue(ctx, bodyCtxKey{}, resBody)
	statusCtx := context.WithValue(bodyCtx, statusCtxKey{}, statusCode)
	return statusCtx, nil
}</code></pre>
<p>This function makes an HTTP request to a specified endpoint on a given port. The function supports both <code>GET</code> and <code>POST</code> methods. If the method is <code>GET</code>, the request body is base64 encoded and added as a query parameter. If the method is <code>POST</code>, the request body is included in the request as JSON data.</p>

<p>For <code>Then the response code should be [code]</code> there is the following implementation:</p>
<pre><code>func theResponseCodeShouldBe(ctx context.Context, expectedCode int) (context.Context, error) {
	// Get Status Code from context
	statusCode, ok := ctx.Value(statusCtxKey{}).(int)
	if !ok {
		return ctx, errors.New("context unaveilable while retrieving status")
	}

	if statusCode != expectedCode {
		// Get Response body from context
		resBody, ok := ctx.Value(bodyCtxKey{}).([]byte)
		if !ok {
			return ctx, errors.New("unaveilable context while retrieving body")
		}

		// Test Failed
		return ctx, fmt.Errorf("received wrong status response. Got %d Expected: %d\nResponse body: %s", statusCode, expectedCode, string(resBody))
	}

	return ctx, nil
}
</code></pre>
<p>This function checks whether the received HTTP response status code matches the expected code.</p>

<p>For <code>And the response should have</code> there is the following implementation:</p>
<pre><code>func theResponseShouldHave(ctx context.Context, body *godog.DocString) error {
	// Get 'ResponseBody' from context
	respBody, ok := ctx.Value(bodyCtxKey{}).([]byte)
	if !ok {
		return errors.New("unavailable context")
	}

	var expected map[string]interface{}
	var received map[string]interface{}

	if err := json.Unmarshal([]byte(body.Content), &expected); err != nil {
		return err
	}
	if err := json.Unmarshal(respBody, &received); err != nil {
		return err
	}

	for key, value := range expected {
		if !reflect.DeepEqual(value, received[key]) {
			var expectedBytes []byte
			var receivedBytes []byte
			var err error
			if expectedBytes, err = json.MarshalIndent(value, "", "  "); err != nil {
				return err
			}
			if receivedBytes, err = json.MarshalIndent(received[key], "", "  "); err != nil {
				return err
			}

			return fmt.Errorf("Expected %s to be equal %s, but received %s", key, expectedBytes, receivedBytes)
		}
	}

	return nil
}</code></pre>
<p>This function checks if the received HTTP response body matches the expected response body defined in the Godog scenario step. It first retrieves the actual response body and the expected response body from the context. It unmarshals both JSON strings into corresponding map-like structures to facilitate comparison. The function performs a deep comparison between the value of each key in the expected and received response bodies using <code>reflect.DeepEqual</code> function.</p>

<p>For <code>And the "[field]" field should have size [size]</code> there is the following implementation:</p>
<pre><code>func theFieldShouldHaveSize(ctx context.Context, field string, expectedSize int) (context.Context, error) {
	// Get 'ResponseBody' from context
	respBody, ok := ctx.Value(bodyCtxKey{}).([]byte)
	if !ok {
		return ctx, errors.New("unavailable context")
	}

	var bodyMap map[string]interface{}

	if err := json.Unmarshal(respBody, &bodyMap); err != nil {
		return ctx, err
	}

	resultField, ok := bodyMap[field]
	if !ok {
		return ctx, errors.New("unavailable filed on body response")
	}

	fieldLen := len(resultField.([]interface{}))
	if fieldLen != expectedSize {
		// Test Failed
		return ctx, fmt.Errorf("received wrong filed size on response body. Got %d Expected: %d\nResponse body: %s", fieldLen, expectedSize, string(respBody))
	}

	return ctx, nil
}
</code></pre>
<p>This function is used to check if a specific field in the received JSON response body has the expected size (number of elements). It is typically used in Godog scenarios to verify the size of an array or a list-like field in the response.</p>

<p>For <code>And there are [number] books with prefix "[prefix]" by author "[name]"</code> there is the following implementation:</p>
<pre><code>func thereAreBooksWithPrefixByAuthor(ctx context.Context, nBooks int, prefix string, author string) (context.Context, error) {
	var res *http.Response
	var err error

	for i := 1; i <= nBooks; i++ {
		// Verify if book already exists
		requestJSON := map[string]interface{}{
			"query": map[string]interface{}{
				"selector": map[string]interface{}{
					"author":     author,
					"title":      prefix + strconv.Itoa(i),
					"@assetType": "book",
				},
			},
			"resolve": true,
		}
		jsonStr, e := json.Marshal(requestJSON)
		if e != nil {
			return ctx, err
		}
		dataAsBytes := bytes.NewBuffer([]byte(jsonStr))

		if res, err = http.Post("http://localhost/api/query/search", "application/json", dataAsBytes); err != nil {
			return ctx, err
		}
		resBody, err := ioutil.ReadAll(res.Body)
		if err != nil {
			return ctx, err
		}
		res.Body.Close()

		var received map[string]interface{}
		if err = json.Unmarshal(resBody, &received); err != nil {
			return ctx, err
		}

		// Create book if it doesnt exists
		if len(received["result"].([]interface{})) == 0 {
			requestJSON := map[string]interface{}{
				"asset": []interface{}{
					map[string]interface{}{
						"author":     author,
						"title":      prefix + strconv.Itoa(i),
						"@assetType": "book",
					},
				},
			}
			jsonStr, e := json.Marshal(requestJSON)
			if e != nil {
				return ctx, err
			}
			dataAsBytes := bytes.NewBuffer([]byte(jsonStr))

			if res, err = http.Post("http://localhost:880/api/invoke/createAsset", "application/json", dataAsBytes); err != nil {
				return ctx, err
			}

			if res.StatusCode != 200 {
				return ctx, errors.New("Failed to create book asset")
			}
		}
	}

	return ctx, nil
}
</code></pre>
<p>This function is used to ensure that there are a specific number of books with a given prefix and author in the system. It is typically used in Godog scenarios to set up the required test data before running tests that involve books and authors.</p>

<p>For <code>Given there is a library with name "[name]"</code> there is the following implementation:</p>
<pre><code>func thereIsALibraryWithName(ctx context.Context, name string) (context.Context, error) {
	var res *http.Response
	var err error

	// Verify if library already exists
	requestJSON := map[string]interface{}{
		"query": map[string]interface{}{
			"selector": map[string]interface{}{
				"name":       name,
				"@assetType": "library",
			},
		},
		"resolve": true,
	}
	jsonStr, e := json.Marshal(requestJSON)
	if e != nil {
		return ctx, err
	}
	dataAsBytes := bytes.NewBuffer([]byte(jsonStr))

	if res, err = http.Post("http://localhost/api/query/search", "application/json", dataAsBytes); err != nil {
		return ctx, err
	}
	resBody, err := ioutil.ReadAll(res.Body)
	if err != nil {
		return ctx, err
	}
	res.Body.Close()

	var received map[string]interface{}
	if err = json.Unmarshal(resBody, &received); err != nil {
		return ctx, err
	}

	// Create library if it doesnt exists
	if len(received["result"].([]interface{})) == 0 {
		requestJSON = map[string]interface{}{
			"asset": []interface{}{
				map[string]interface{}{
					"name":       name,
					"@assetType": "library",
				},
			},
		}
		jsonStr, e = json.Marshal(requestJSON)
		if e != nil {
			return ctx, err
		}
		dataAsBytes = bytes.NewBuffer([]byte(jsonStr))

		if res, err = http.Post("http://localhost:880/api/invoke/createAsset", "application/json", dataAsBytes); err != nil {
			return ctx, err
		}

		if res.StatusCode != 200 {
			return ctx, errors.New("Failed to create library asset")
		}
	}

	return ctx, nil
}</code></pre>
<p>This function is used to ensure that a library with a specific name exists in the system. It is typically used in Godog scenarios to set up the required test data before running tests that involve libraries. If the library does not exist, it creates a new library asset.</p>

<p>It's required to initialize the scenario with the implementation of each step. The function below describes how to do it:</p>
<pre><code>func InitializeScenario(ctx *godog.ScenarioContext) {
	ctx.Step(`^I make a "([^"]*)" request to "([^"]*)" on port (\d+) with:$`, iMakeARequestToOnPortWith)
	ctx.Step(`^the response code should be (\d+)$`, theResponseCodeShouldBe)
	ctx.Step(`^the response should have:$`, theResponseShouldHave)
	ctx.Step(`^there is a running "([^"]*)" test network$`, thereIsARunningTestNetwork)
	ctx.Step(`^there is a running "([^"]*)" test network from scratch$`, thereIsARunningTestNetworkFromScratch)
	ctx.Step(`^there are (\d+) books with prefix "([^"]*)" by author "([^"]*)"$`, thereAreBooksWithPrefixByAuthor)
	ctx.Step(`^the "([^"]*)" field should have size (\d+)$`, theFieldShouldHaveSize)
	ctx.Step(`^there is a library with name "([^"]*)"$`, thereIsALibraryWithName)
}</code></pre>
<h3 id="run-godog-tests">Run Godog tests</h3>
<p>Begin by installing godog using the following command:</p>
<pre><code>$ go install github.com/cucumber/godog/cmd/godog@latest</code></pre>
<p>Once godog is successfully installed, utilize the provided script to run tests effortlessly:</p>
<pre><code>$ ./godog.sh</code></pre>
<p></p>
          </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="../external-tools/" class="btn btn-neutral" title="External Tools"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../external-tools/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
