{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to CC-Tools documentation \ud83d\udc4b The GoLedger CC-Tools library is a collaborative effort from GoLedger to provide developers a powerful and easy-to-use library for creating Hyperledger Fabric chaincodes. Developed using GoLang, the GoLedger CC-Tools library has several features that facilitate the journey of learning, development and deployment in production of a chaincode. GoLedger CC-Tools is an open-source project led by GoLedger and open for use to the Hyperledger development community. Here's where you can start: Getting Started Tutorials Key concepts Assets Datatypes Events Transactions External Tools Testing Reference guides This documentation page is in constant development... Join our Discord ! Features Standard asset data mapping (and their properties) Encapsulation of Hyperledger Fabric chaincode sdk interface functions Standard asset key management Basic types of asset properties (text, number, boolean, date) available Basic asset array type (text, number or date arrays) available New asset property types customization Asset within assets available as references Asset array available as references Management of asset details Write permissions by set of organizations for each asset's property Private data collections management by asset (read permissions) Create/Read/Update/Delete (CRUD) transactions embedded Custom transactions, with prior definition of arguments, webservice method (GET, POST etc) Management of transaction details Compatible web service Compatible ready-to-use web application","title":"Home"},{"location":"#welcome-to-cc-tools-documentation","text":"The GoLedger CC-Tools library is a collaborative effort from GoLedger to provide developers a powerful and easy-to-use library for creating Hyperledger Fabric chaincodes. Developed using GoLang, the GoLedger CC-Tools library has several features that facilitate the journey of learning, development and deployment in production of a chaincode. GoLedger CC-Tools is an open-source project led by GoLedger and open for use to the Hyperledger development community. Here's where you can start: Getting Started Tutorials Key concepts Assets Datatypes Events Transactions External Tools Testing Reference guides This documentation page is in constant development... Join our Discord !","title":"Welcome to CC-Tools documentation \ud83d\udc4b"},{"location":"#features","text":"Standard asset data mapping (and their properties) Encapsulation of Hyperledger Fabric chaincode sdk interface functions Standard asset key management Basic types of asset properties (text, number, boolean, date) available Basic asset array type (text, number or date arrays) available New asset property types customization Asset within assets available as references Asset array available as references Management of asset details Write permissions by set of organizations for each asset's property Private data collections management by asset (read permissions) Create/Read/Update/Delete (CRUD) transactions embedded Custom transactions, with prior definition of arguments, webservice method (GET, POST etc) Management of transaction details Compatible web service Compatible ready-to-use web application","title":"Features"},{"location":"assets/","text":"Assets Blockchain assets represent the information that will be used by the Blockchain ledger ( Hyperledger Fabric Channel ) Roughly speaking, an asset can be compared to a table in a relational database. And just like in databases, assets are formed by properties, some of which can be part of a set of keys for that asset. Each property can have a specific data type, such as string, number, boolean, etc. An asset can also be a Hyperledger Fabric Private Data , in which the information content is recorded in a transient database outside the ledger and only a subset of organizations receive this data, configuring readability. Assets can also be created dynamically during the chaincode execution, using CC-Tool's Dynamic Asset Types funcionality, in which asset types are defined using invoke calls to the running chaincode. For the cc-tools-demo repository, there are 4 assets (one of which is a private data) Person Book Library Secret (private data) In order to use GoLedger CC-Tools library, the assets definition is done in the chaincode/assettypes folder Here follow the list of files: chaincode/ assettypes/ # assets folder person.go # definition of a person book.go # definition of a book library.go # definition of a library secret.go # definitions of secret (private data) customAssets.go # list of assets inserted via GoFabric's Template mode dynamicAssetTypes.go # configuration file for Dynamic Asset Types assetTypeList.go # list of assets instantiated Asset definition The construction and definition of an asset is done by creating a file at chaincode/assettypes folder An asset has the following fields Tag : string field used to define the name of the asset referenced internally by the code and by the Rest API endpoints. No space or special characters allowed. Label : string field to define the label to be used by external applications. Free text. Description : asset description string field to be used by external applications. Free text. Props : asset properties. It has its own fields (description next) Readers : used to define private data organizations. If not empty, only the organizations defined in the array will have the ability to read assets from the type. Validate : asset validation function. Allows for a custom code to validate the asset as a whole. Dynamic : boolean field to indicate that the asset type can be modified dynamically. For coded assets it is recommended to leave it as false and use the upgrade chaincode funcionality to update the asset definition. Property definition An asset has a set of properties (Props) to structure the asset. A property has the following fields: Tag : string field used to define the name of the property referenced internally by the code and by the Rest API endpoints. No space or special characters allowed. Label : string field to define the label to be used by external applications. Free text. Description : property description string field to be used by external applications. Free text. IsKey : identifies if the property is part of the asset's keys. Boolean field. Required : identifies if the property is mandatory. Boolean field. ReadOnly : identifies if the property can no longer be modified once created. Boolean field. DefaultValue : property default value. Writers : define the organizations that can create or change this property. If the property is key (isKey field: true) then the entire asset can only be created by the organization. List of strings. DataType : property type. CC-Tools has the following default types: string, number, datetime and boolean . Custom types can be defined in the chaincode/datatypes folder. Arrays and references to other asset types are also possible. Validate : property validation function. It is suggested only for simple validations, more complex functions should use custom datatypes. Asset examples The cc-tools-demo repository has the following examples: chaincode/ assettypes/ # assets folder person.go # definition of a person book.go # definition of a book library.go # definition of a library secret.go # definitions of secret (private data) customAssets.go # list of assets inserted via GoFabric's Template mode dynamicAssetTypes.go # configuration file for Dynamic Asset Types assetTypeList.go # list of assets instantiated Besides the files of each asset, you must register the assets that can be used by the Goledger CC-Tools library in the assetTypeList.go file The definition of the Person asset is as follows: var Person = assets.AssetType{ Tag: \"person\", Label: \"Person\", Description: \"Personal data of someone\", Props: []assets.AssetProp{ { // Primary key Required: true, IsKey: true, Tag: \"id\", Label: \"CPF (Brazilian ID)\", DataType: \"cpf\", // Datatypes are identified at datatypes folder Writers: []string{`org1MSP`, \"orgMSP\"}, // This means only org1 and org can create the asset (others can edit) }, { // Mandatory property Required: true, Tag: \"name\", Label: \"Name of the person\", DataType: \"string\", // Validate funcion Validate: func(name interface{}) error { nameStr := name.(string) if nameStr == \"\" { return fmt.Errorf(\"name must be non-empty\") } return nil }, }, { // Optional property Tag: \"dateOfBirth\", Label: \"Date of Birth\", DataType: \"datetime\", }, { // Property with default value Tag: \"height\", Label: \"Person's height\", DefaultValue: 0, DataType: \"number\", }, }, } According to the description above, the asset Person has the following characteristics: Primary key cpf (custom datatype) Only org1 and org can create or change the cpf property and the Person asset (because this is a key) Property name of type string is mandatory, and has automatic validation to prevent empty strings (\"\") dateofBirth property of type datetime optional. height property of type number , with default value 0 The definition of the Book asset is as follows: var Book = assets.AssetType{ Tag: \"book\", Label: \"Book\", Description: \"Book\", Props: []assets.AssetProp{ { // Composite Key Required: true, IsKey: true, Tag: \"title\", Label: \"Book Title\", DataType: \"string\", Writers: []string{`org2MSP`, \"orgMSP\"}, // This means only org2 and org can create the asset (others can edit) }, { // Composite Key Required: true, IsKey: true, Tag: \"author\", Label: \"Book Author\", DataType: \"string\", Writers: []string{`org2MSP`, \"orgMSP\"}, // This means only org2 and org can create the asset (others can edit) }, { /// Reference to another asset Tag: \"currentTenant\", Label: \"Current Tenant\", DataType: \"->person\", }, { // String list Tag: \"genres\", Label: \"Genres\", DataType: \"[]string\", }, { // Date property Tag: \"published\", Label: \"Publishment Date\", DataType: \"datetime\", }, { // Custom data type Tag: \"bookType\", Label: \"Book Type\", DataType: \"bookType\", }, }, } According to the description above, the Book asset has the following characteristics: Composite key title and author , both with type string Only org2 and org can create or change the title and author properties and the Book asset (because they are keys) currentTenant property of type ->person which represents the reference to a Person asset genres property of type []string which represents an array of strings published property of type datetime bookType property is of custom datatype bookType , defined in chaincode/datatypes folder The definition of the Library asset is as follows: var Library = assets.AssetType{ Tag: \"library\", Label: \"Library\", Description: \"Library as a collection of books\", Props: []assets.AssetProp{ { // Primary Key Required: true, IsKey: true, Tag: \"name\", Label: \"Library Name\", DataType: \"string\", Writers: []string{`org3MSP`, \"orgMSP\"}, // This means only org3 and org can create the asset (others can edit) }, { // Asset reference list Tag: \"books\", Label: \"Book Collection\", DataType: \"[]->book\", }, { // Asset reference list Tag: \"entranceCode\", Label: \"Entrance Code for the Library\", DataType: \"->secret\", }, }, } According to the description above, the Library asset has the following characteristics: Primary key name of type string Only org3 and org can create or change the name property and the Library asset (because it's key) books property of type []->book which represents an array of references to the Book asset entranceCode property of type ->secret which represents the reference to a private data type The definition of the Secret asset is as follows: var Secret = assets.AssetType{ Tag: \"secret\", Label: \"Secret\", Description: \"Secret between Org2 and Org3\", Readers: []string{\"org2MSP\", \"org3MSP\", , \"orgMSP\"}, Props: []assets.AssetProp{ { // Primary Key IsKey: true, Tag: \"secretName\", Label: \"Secret Name\", DataType: \"string\", Writers: []string{`org2MSP`, , \"orgMSP\"}, // This means only org2 and org can create the asset (org3 can edit) }, { // Mandatory Property Required: true, Tag: \"secret\", Label: \"Secret\", DataType: \"string\", }, }, } According to the description above, Secret asset has privacy features ( Hyperledger Fabric Private Data ). We will not describe Hyperledger Fabric Private Data concepts, its operation, policy rules, etc. But to put it simply, when an asset is defined as private, only its content hash is recorded in channel , the asset's content (its properties) are only accessed by a limited set of organizations, the content recorded in transient databases in each peer. Asset content can only be read by org , org2 and org3 Primary key secretName of type string Only org2 and org can create or change the secretName property and the Secret asset (because it is key) secret property of type string is mandatory for the asset Both org , org2 and org3 can create or change the secret property Asset list definition GoLedger CC-Tools assets registration must be defined in the chaincode/assetTypeList.go file** var assetTypeList = []assets.AssetType{ assettypes.Person, assettypes.Book, assettypes.Library, assettypes.Secret, } Dynamic Asset Types The previous sections of this page described statcally created assets, by manually programming into the code. But CC-Tools also allows for dynamically definition and creation of assets during runtime, through invokes for the chaincode. Configuration The configuration for the dynamic asset types are stored on the dyanmicAssetTypes.go file on cc-tools-demo. The configuration has the following options: Enabled : defines whether dynamic assets types are enabled or disabled during runtime Readers : used to specify which organizations are allowed to dynamically create and manage asset type Managing asset types dynamically CC-Tools offers three built-in transactions to manage asset types dynamically, createAssetType , updateAssetType and deleteAssetType . Using the standard cc-tools-demo API for org1, these transactions can be accessed using a POST request to http://<HOST-IP>:80/api/invoke/<TRANSACTION-TAG> , with the information about the modified assets being sent in the JSON body of the request. These transactions can also be access using the GoInitus interface. Creating asset types The asset type to be created should be sent on the assetTypes array on the request body. Each object on the array should contain the fields definig the type to be created, as seen on the asset definition , with the exception of the Validate field, which is not supported by the dynamic asset types. Alongside the asset field, the props array should be used to define the asset type properties. Each object on the array should contain the property fields, as seen on the property definition . Once again, the Validate option is not available for the properties. An example payload to create a new type can be seen below: { \"assetTypes\": [ { \"tag\": \"collection\", \"label\": \"Collection\", \"description\": \"A collection of books\", \"props\": [ { \"tag\": \"name\", \"label\": \"Name\", \"description\": \"Name\", \"dataType\": \"string\", \"required\": true, \"isKey\": true }, { \"tag\": \"rating\", \"label\": \"Rating\", \"description\": \"Rating\", \"dataType\": \"number\", \"defaultValue\": 10, }, { \"tag\": \"books\", \"label\": \"Books\", \"dataType\": \"[]->book\", \"writers\": [\"org2MSP\"] } ] } ] } Updating asset types CC-Tools allows the update of asset types in the same manner used in the creation process. Note that only types created dynamically or those coded with the Dynamic option set as true can be updated dynamically. When updating a statically coded asset, be careful when upgrading the chaincode version, since the coded type will be used when rebuilding the asset type list To update the asset, only the properties and fields that will be modified can be sent. The only required field for all types and properties to be modified is the tag , as means of identification. It's also impossible to modify the Tag for a type or property dynamically. It's also possible to delete an existing property of a type by setting the delete field as true, as long as the property in question is not a key. An example payload to update a new type can be seen below: { \"assetTypes\": [ { \"tag\": \"collection\", \"description\": \"A book collection series\", \"props\": [ { \"tag\": \"rating\", \"delete\": true }, { \"tag\": \"name\", \"description\": \"The collection name\" } ] } ] } Deleting asset types CC-Tools also allows the deletion of asset types. Just like when updating, only types created dynamically or those coded with the Dynamic option set as true can be deleted dynamically. The assetTypes array objects for the deletion request only requires the tag of the type to be deleted. By default, if any asset of the type exists in the blockchain, the deletion of the asset will not be allowed. To force the deletion, the force option can be sent alongside the tag. Also note that, if any other type reference the type being deleted, the deletion process will fail. An example payload to update a new type can be seen below: { \"assetTypes\": [ { \"tag\": \"collection\", \"force\": true } ] }","title":"Assets"},{"location":"assets/#assets","text":"Blockchain assets represent the information that will be used by the Blockchain ledger ( Hyperledger Fabric Channel ) Roughly speaking, an asset can be compared to a table in a relational database. And just like in databases, assets are formed by properties, some of which can be part of a set of keys for that asset. Each property can have a specific data type, such as string, number, boolean, etc. An asset can also be a Hyperledger Fabric Private Data , in which the information content is recorded in a transient database outside the ledger and only a subset of organizations receive this data, configuring readability. Assets can also be created dynamically during the chaincode execution, using CC-Tool's Dynamic Asset Types funcionality, in which asset types are defined using invoke calls to the running chaincode. For the cc-tools-demo repository, there are 4 assets (one of which is a private data) Person Book Library Secret (private data) In order to use GoLedger CC-Tools library, the assets definition is done in the chaincode/assettypes folder Here follow the list of files: chaincode/ assettypes/ # assets folder person.go # definition of a person book.go # definition of a book library.go # definition of a library secret.go # definitions of secret (private data) customAssets.go # list of assets inserted via GoFabric's Template mode dynamicAssetTypes.go # configuration file for Dynamic Asset Types assetTypeList.go # list of assets instantiated","title":"Assets"},{"location":"assets/#asset-definition","text":"The construction and definition of an asset is done by creating a file at chaincode/assettypes folder An asset has the following fields Tag : string field used to define the name of the asset referenced internally by the code and by the Rest API endpoints. No space or special characters allowed. Label : string field to define the label to be used by external applications. Free text. Description : asset description string field to be used by external applications. Free text. Props : asset properties. It has its own fields (description next) Readers : used to define private data organizations. If not empty, only the organizations defined in the array will have the ability to read assets from the type. Validate : asset validation function. Allows for a custom code to validate the asset as a whole. Dynamic : boolean field to indicate that the asset type can be modified dynamically. For coded assets it is recommended to leave it as false and use the upgrade chaincode funcionality to update the asset definition.","title":"Asset definition"},{"location":"assets/#property-definition","text":"An asset has a set of properties (Props) to structure the asset. A property has the following fields: Tag : string field used to define the name of the property referenced internally by the code and by the Rest API endpoints. No space or special characters allowed. Label : string field to define the label to be used by external applications. Free text. Description : property description string field to be used by external applications. Free text. IsKey : identifies if the property is part of the asset's keys. Boolean field. Required : identifies if the property is mandatory. Boolean field. ReadOnly : identifies if the property can no longer be modified once created. Boolean field. DefaultValue : property default value. Writers : define the organizations that can create or change this property. If the property is key (isKey field: true) then the entire asset can only be created by the organization. List of strings. DataType : property type. CC-Tools has the following default types: string, number, datetime and boolean . Custom types can be defined in the chaincode/datatypes folder. Arrays and references to other asset types are also possible. Validate : property validation function. It is suggested only for simple validations, more complex functions should use custom datatypes.","title":"Property definition"},{"location":"assets/#asset-examples","text":"The cc-tools-demo repository has the following examples: chaincode/ assettypes/ # assets folder person.go # definition of a person book.go # definition of a book library.go # definition of a library secret.go # definitions of secret (private data) customAssets.go # list of assets inserted via GoFabric's Template mode dynamicAssetTypes.go # configuration file for Dynamic Asset Types assetTypeList.go # list of assets instantiated Besides the files of each asset, you must register the assets that can be used by the Goledger CC-Tools library in the assetTypeList.go file The definition of the Person asset is as follows: var Person = assets.AssetType{ Tag: \"person\", Label: \"Person\", Description: \"Personal data of someone\", Props: []assets.AssetProp{ { // Primary key Required: true, IsKey: true, Tag: \"id\", Label: \"CPF (Brazilian ID)\", DataType: \"cpf\", // Datatypes are identified at datatypes folder Writers: []string{`org1MSP`, \"orgMSP\"}, // This means only org1 and org can create the asset (others can edit) }, { // Mandatory property Required: true, Tag: \"name\", Label: \"Name of the person\", DataType: \"string\", // Validate funcion Validate: func(name interface{}) error { nameStr := name.(string) if nameStr == \"\" { return fmt.Errorf(\"name must be non-empty\") } return nil }, }, { // Optional property Tag: \"dateOfBirth\", Label: \"Date of Birth\", DataType: \"datetime\", }, { // Property with default value Tag: \"height\", Label: \"Person's height\", DefaultValue: 0, DataType: \"number\", }, }, } According to the description above, the asset Person has the following characteristics: Primary key cpf (custom datatype) Only org1 and org can create or change the cpf property and the Person asset (because this is a key) Property name of type string is mandatory, and has automatic validation to prevent empty strings (\"\") dateofBirth property of type datetime optional. height property of type number , with default value 0 The definition of the Book asset is as follows: var Book = assets.AssetType{ Tag: \"book\", Label: \"Book\", Description: \"Book\", Props: []assets.AssetProp{ { // Composite Key Required: true, IsKey: true, Tag: \"title\", Label: \"Book Title\", DataType: \"string\", Writers: []string{`org2MSP`, \"orgMSP\"}, // This means only org2 and org can create the asset (others can edit) }, { // Composite Key Required: true, IsKey: true, Tag: \"author\", Label: \"Book Author\", DataType: \"string\", Writers: []string{`org2MSP`, \"orgMSP\"}, // This means only org2 and org can create the asset (others can edit) }, { /// Reference to another asset Tag: \"currentTenant\", Label: \"Current Tenant\", DataType: \"->person\", }, { // String list Tag: \"genres\", Label: \"Genres\", DataType: \"[]string\", }, { // Date property Tag: \"published\", Label: \"Publishment Date\", DataType: \"datetime\", }, { // Custom data type Tag: \"bookType\", Label: \"Book Type\", DataType: \"bookType\", }, }, } According to the description above, the Book asset has the following characteristics: Composite key title and author , both with type string Only org2 and org can create or change the title and author properties and the Book asset (because they are keys) currentTenant property of type ->person which represents the reference to a Person asset genres property of type []string which represents an array of strings published property of type datetime bookType property is of custom datatype bookType , defined in chaincode/datatypes folder The definition of the Library asset is as follows: var Library = assets.AssetType{ Tag: \"library\", Label: \"Library\", Description: \"Library as a collection of books\", Props: []assets.AssetProp{ { // Primary Key Required: true, IsKey: true, Tag: \"name\", Label: \"Library Name\", DataType: \"string\", Writers: []string{`org3MSP`, \"orgMSP\"}, // This means only org3 and org can create the asset (others can edit) }, { // Asset reference list Tag: \"books\", Label: \"Book Collection\", DataType: \"[]->book\", }, { // Asset reference list Tag: \"entranceCode\", Label: \"Entrance Code for the Library\", DataType: \"->secret\", }, }, } According to the description above, the Library asset has the following characteristics: Primary key name of type string Only org3 and org can create or change the name property and the Library asset (because it's key) books property of type []->book which represents an array of references to the Book asset entranceCode property of type ->secret which represents the reference to a private data type The definition of the Secret asset is as follows: var Secret = assets.AssetType{ Tag: \"secret\", Label: \"Secret\", Description: \"Secret between Org2 and Org3\", Readers: []string{\"org2MSP\", \"org3MSP\", , \"orgMSP\"}, Props: []assets.AssetProp{ { // Primary Key IsKey: true, Tag: \"secretName\", Label: \"Secret Name\", DataType: \"string\", Writers: []string{`org2MSP`, , \"orgMSP\"}, // This means only org2 and org can create the asset (org3 can edit) }, { // Mandatory Property Required: true, Tag: \"secret\", Label: \"Secret\", DataType: \"string\", }, }, } According to the description above, Secret asset has privacy features ( Hyperledger Fabric Private Data ). We will not describe Hyperledger Fabric Private Data concepts, its operation, policy rules, etc. But to put it simply, when an asset is defined as private, only its content hash is recorded in channel , the asset's content (its properties) are only accessed by a limited set of organizations, the content recorded in transient databases in each peer. Asset content can only be read by org , org2 and org3 Primary key secretName of type string Only org2 and org can create or change the secretName property and the Secret asset (because it is key) secret property of type string is mandatory for the asset Both org , org2 and org3 can create or change the secret property","title":"Asset examples"},{"location":"assets/#asset-list-definition","text":"GoLedger CC-Tools assets registration must be defined in the chaincode/assetTypeList.go file** var assetTypeList = []assets.AssetType{ assettypes.Person, assettypes.Book, assettypes.Library, assettypes.Secret, }","title":"Asset list definition"},{"location":"assets/#dynamic-asset-types","text":"The previous sections of this page described statcally created assets, by manually programming into the code. But CC-Tools also allows for dynamically definition and creation of assets during runtime, through invokes for the chaincode.","title":"Dynamic Asset Types"},{"location":"assets/#configuration","text":"The configuration for the dynamic asset types are stored on the dyanmicAssetTypes.go file on cc-tools-demo. The configuration has the following options: Enabled : defines whether dynamic assets types are enabled or disabled during runtime Readers : used to specify which organizations are allowed to dynamically create and manage asset type","title":"Configuration"},{"location":"assets/#managing-asset-types-dynamically","text":"CC-Tools offers three built-in transactions to manage asset types dynamically, createAssetType , updateAssetType and deleteAssetType . Using the standard cc-tools-demo API for org1, these transactions can be accessed using a POST request to http://<HOST-IP>:80/api/invoke/<TRANSACTION-TAG> , with the information about the modified assets being sent in the JSON body of the request. These transactions can also be access using the GoInitus interface.","title":"Managing asset types dynamically"},{"location":"assets/#creating-asset-types","text":"The asset type to be created should be sent on the assetTypes array on the request body. Each object on the array should contain the fields definig the type to be created, as seen on the asset definition , with the exception of the Validate field, which is not supported by the dynamic asset types. Alongside the asset field, the props array should be used to define the asset type properties. Each object on the array should contain the property fields, as seen on the property definition . Once again, the Validate option is not available for the properties. An example payload to create a new type can be seen below: { \"assetTypes\": [ { \"tag\": \"collection\", \"label\": \"Collection\", \"description\": \"A collection of books\", \"props\": [ { \"tag\": \"name\", \"label\": \"Name\", \"description\": \"Name\", \"dataType\": \"string\", \"required\": true, \"isKey\": true }, { \"tag\": \"rating\", \"label\": \"Rating\", \"description\": \"Rating\", \"dataType\": \"number\", \"defaultValue\": 10, }, { \"tag\": \"books\", \"label\": \"Books\", \"dataType\": \"[]->book\", \"writers\": [\"org2MSP\"] } ] } ] }","title":"Creating asset types"},{"location":"assets/#updating-asset-types","text":"CC-Tools allows the update of asset types in the same manner used in the creation process. Note that only types created dynamically or those coded with the Dynamic option set as true can be updated dynamically. When updating a statically coded asset, be careful when upgrading the chaincode version, since the coded type will be used when rebuilding the asset type list To update the asset, only the properties and fields that will be modified can be sent. The only required field for all types and properties to be modified is the tag , as means of identification. It's also impossible to modify the Tag for a type or property dynamically. It's also possible to delete an existing property of a type by setting the delete field as true, as long as the property in question is not a key. An example payload to update a new type can be seen below: { \"assetTypes\": [ { \"tag\": \"collection\", \"description\": \"A book collection series\", \"props\": [ { \"tag\": \"rating\", \"delete\": true }, { \"tag\": \"name\", \"description\": \"The collection name\" } ] } ] }","title":"Updating asset types"},{"location":"assets/#deleting-asset-types","text":"CC-Tools also allows the deletion of asset types. Just like when updating, only types created dynamically or those coded with the Dynamic option set as true can be deleted dynamically. The assetTypes array objects for the deletion request only requires the tag of the type to be deleted. By default, if any asset of the type exists in the blockchain, the deletion of the asset will not be allowed. To force the deletion, the force option can be sent alongside the tag. Also note that, if any other type reference the type being deleted, the deletion process will fail. An example payload to update a new type can be seen below: { \"assetTypes\": [ { \"tag\": \"collection\", \"force\": true } ] }","title":"Deleting asset types"},{"location":"datatypes/","text":"Datatypes GoLedger CC-Tools datatypes are a way to categorize and define the nature of a data that can be stored in an asset and manipulated in transactions. It's essential to validate that the data entered matches the expected data type. CC-Tools provides some primitive datatypes. Here are them: string : represents a sequence of characters. number : represents a 64 bits floating-point. integer : represents whole numbers The size depends on the underlying architecture and can vary between 32 bits and 64 bits boolean : represents two possible values: true and false. datetime : represents a date in RFC3339 format, e.g. \"2019-05-06T22:12:41Z\". @object : represents a string in JSON format. It is typically used to define the structure and properties of a JSON object. It's made up of key-value pairs. It also allows developers to inject custom primitive data types. In order to use GoLedger CC-Tools library, the datatypes definition is done in the chaincode/datatypes folder Here follow the list of files: chaincode/ datatypes/ # custom datatype folders bookType.go # definition of a book type cpf.go # definition of a cpf datatypes.go # list of datatypes instantiated Datatype definition The construction and definition of a custom datatype is done by creating a file at chaincode/datatypes folder An datatype has the following fields AcceptedFormats : list of \"core\" types that can be accepted (string, number, integer, boolean, datetime). Description : text describing the data type. DropDownValues : set of predetermined values to be used in a dropdown menu on frontend rendering. Parse : function called to check if the input value is valid, make necessary conversions and return a string representation of the value. Datatype examples The cc-tools-demo repository has the following examples: chaincode/ datatypes/ # datatypes folders bookType.go # definition of a book type cpf.go # definition of a cpf datatypes.go # list of datatypes instantiated Besides the files of each datatype, you must register the datatypes that can be used by the Goledger CC-Tools library in the datatypes.go file The definition of the bookType datatype is as follows: type BookType float64 const ( BookTypeHardcover BookType = iota BookTypePaperback BookTypeEbook ) // CheckType checks if the given value is defined as valid BookType consts func (b BookType) CheckType() errors.ICCError { switch b { case BookTypeHardcover: return nil case BookTypePaperback: return nil case BookTypeEbook: return nil default: return errors.NewCCError(\"invalid type\", 400) } } var bookType = assets.DataType{ AcceptedFormats: []string{\"number\"}, DropDownValues: map[string]interface{}{ \"Hardcover\": BookTypeHardcover, \"Paperback\": BookTypePaperback, \"Ebook\": BookTypeEbook, }, Description: ``, Parse: func(data interface{}) (string, interface{}, errors.ICCError) { var dataVal float64 switch v := data.(type) { case float64: dataVal = v case int: dataVal = (float64)(v) case BookType: dataVal = (float64)(v) case string: var err error dataVal, err = strconv.ParseFloat(v, 64) if err != nil { return \"\", nil, errors.WrapErrorWithStatus(err, \"asset property must be an integer, is %t\", 400) } default: return \"\", nil, errors.NewCCError(\"asset property must be an integer, is %t\", 400) } retVal := (BookType)(dataVal) err := retVal.CheckType() return fmt.Sprint(retVal), retVal, err }, } According to the description above, the datatype bookType has the following characteristics: It represents an enumerated type Accepted values are the numbers 0, 1 and 2, which represent book types Hardcover , Paperback and Ebook , respectively Parse function receives the input value, parse it to float64 and check number is valid in CheckType function The definition of the cpf datatype is as follows: var cpf = assets.DataType{ AcceptedFormats: []string{\"string\"}, Parse: func(data interface{}) (string, interface{}, errors.ICCError) { cpf, ok := data.(string) if !ok { return \"\", nil, errors.NewCCError(\"property must be a string\", 400) } cpf = strings.ReplaceAll(cpf, \".\", \"\") cpf = strings.ReplaceAll(cpf, \"-\", \"\") if len(cpf) != 11 { return \"\", nil, errors.NewCCError(\"CPF must have 11 digits\", 400) } var vd0 int for i, d := range cpf { if i >= 9 { break } dnum := int(d) - '0' vd0 += (10 - i) * dnum } vd0 = 11 - vd0%11 if vd0 > 9 { vd0 = 0 } if int(cpf[9])-'0' != vd0 { return \"\", nil, errors.NewCCError(\"Invalid CPF\", 400) } var vd1 int for i, d := range cpf { if i >= 10 { break } dnum := int(d) - '0' vd1 += (11 - i) * dnum } vd1 = 11 - vd1%11 if vd1 > 9 { vd1 = 0 } if int(cpf[10])-'0' != vd1 { return \"\", nil, errors.NewCCError(\"Invalid CPF\", 400) } return cpf, cpf, nil }, } According to the description above, the cpf datatype has the following characteristics: It accepts a string as input in the CPF standard format, e.g. \"861.232.710-59\". Punctuation is not required. Parse function validates that the provided CPF numbers adhere to the correct structure, including the required digits and verification algorithm. Datatype list definition GoLedger CC-Tools custom datatypes registration must be defined in the chaincode/datatypes/datatypes.go file** var CustomDataTypes = map[string]assets.DataType{ \"cpf\": cpf, \"bookType\": bookType, }","title":"Datatypes"},{"location":"datatypes/#datatypes","text":"GoLedger CC-Tools datatypes are a way to categorize and define the nature of a data that can be stored in an asset and manipulated in transactions. It's essential to validate that the data entered matches the expected data type. CC-Tools provides some primitive datatypes. Here are them: string : represents a sequence of characters. number : represents a 64 bits floating-point. integer : represents whole numbers The size depends on the underlying architecture and can vary between 32 bits and 64 bits boolean : represents two possible values: true and false. datetime : represents a date in RFC3339 format, e.g. \"2019-05-06T22:12:41Z\". @object : represents a string in JSON format. It is typically used to define the structure and properties of a JSON object. It's made up of key-value pairs. It also allows developers to inject custom primitive data types. In order to use GoLedger CC-Tools library, the datatypes definition is done in the chaincode/datatypes folder Here follow the list of files: chaincode/ datatypes/ # custom datatype folders bookType.go # definition of a book type cpf.go # definition of a cpf datatypes.go # list of datatypes instantiated","title":"Datatypes"},{"location":"datatypes/#datatype-definition","text":"The construction and definition of a custom datatype is done by creating a file at chaincode/datatypes folder An datatype has the following fields AcceptedFormats : list of \"core\" types that can be accepted (string, number, integer, boolean, datetime). Description : text describing the data type. DropDownValues : set of predetermined values to be used in a dropdown menu on frontend rendering. Parse : function called to check if the input value is valid, make necessary conversions and return a string representation of the value.","title":"Datatype definition"},{"location":"datatypes/#datatype-examples","text":"The cc-tools-demo repository has the following examples: chaincode/ datatypes/ # datatypes folders bookType.go # definition of a book type cpf.go # definition of a cpf datatypes.go # list of datatypes instantiated Besides the files of each datatype, you must register the datatypes that can be used by the Goledger CC-Tools library in the datatypes.go file The definition of the bookType datatype is as follows: type BookType float64 const ( BookTypeHardcover BookType = iota BookTypePaperback BookTypeEbook ) // CheckType checks if the given value is defined as valid BookType consts func (b BookType) CheckType() errors.ICCError { switch b { case BookTypeHardcover: return nil case BookTypePaperback: return nil case BookTypeEbook: return nil default: return errors.NewCCError(\"invalid type\", 400) } } var bookType = assets.DataType{ AcceptedFormats: []string{\"number\"}, DropDownValues: map[string]interface{}{ \"Hardcover\": BookTypeHardcover, \"Paperback\": BookTypePaperback, \"Ebook\": BookTypeEbook, }, Description: ``, Parse: func(data interface{}) (string, interface{}, errors.ICCError) { var dataVal float64 switch v := data.(type) { case float64: dataVal = v case int: dataVal = (float64)(v) case BookType: dataVal = (float64)(v) case string: var err error dataVal, err = strconv.ParseFloat(v, 64) if err != nil { return \"\", nil, errors.WrapErrorWithStatus(err, \"asset property must be an integer, is %t\", 400) } default: return \"\", nil, errors.NewCCError(\"asset property must be an integer, is %t\", 400) } retVal := (BookType)(dataVal) err := retVal.CheckType() return fmt.Sprint(retVal), retVal, err }, } According to the description above, the datatype bookType has the following characteristics: It represents an enumerated type Accepted values are the numbers 0, 1 and 2, which represent book types Hardcover , Paperback and Ebook , respectively Parse function receives the input value, parse it to float64 and check number is valid in CheckType function The definition of the cpf datatype is as follows: var cpf = assets.DataType{ AcceptedFormats: []string{\"string\"}, Parse: func(data interface{}) (string, interface{}, errors.ICCError) { cpf, ok := data.(string) if !ok { return \"\", nil, errors.NewCCError(\"property must be a string\", 400) } cpf = strings.ReplaceAll(cpf, \".\", \"\") cpf = strings.ReplaceAll(cpf, \"-\", \"\") if len(cpf) != 11 { return \"\", nil, errors.NewCCError(\"CPF must have 11 digits\", 400) } var vd0 int for i, d := range cpf { if i >= 9 { break } dnum := int(d) - '0' vd0 += (10 - i) * dnum } vd0 = 11 - vd0%11 if vd0 > 9 { vd0 = 0 } if int(cpf[9])-'0' != vd0 { return \"\", nil, errors.NewCCError(\"Invalid CPF\", 400) } var vd1 int for i, d := range cpf { if i >= 10 { break } dnum := int(d) - '0' vd1 += (11 - i) * dnum } vd1 = 11 - vd1%11 if vd1 > 9 { vd1 = 0 } if int(cpf[10])-'0' != vd1 { return \"\", nil, errors.NewCCError(\"Invalid CPF\", 400) } return cpf, cpf, nil }, } According to the description above, the cpf datatype has the following characteristics: It accepts a string as input in the CPF standard format, e.g. \"861.232.710-59\". Punctuation is not required. Parse function validates that the provided CPF numbers adhere to the correct structure, including the required digits and verification algorithm.","title":"Datatype examples"},{"location":"datatypes/#datatype-list-definition","text":"GoLedger CC-Tools custom datatypes registration must be defined in the chaincode/datatypes/datatypes.go file** var CustomDataTypes = map[string]assets.DataType{ \"cpf\": cpf, \"bookType\": bookType, }","title":"Datatype list definition"},{"location":"events/","text":"Events Hyperledger Fabric allows client applications (such as the rest-server API) to receive block events while block are commited to the peer's ledger. CC-Tools have a built-in event funcionality that allows for a quick register of the event, which will automatically be listened and handled by the standard CCAPI. The events in CC-Tools can be of three types: log , registering the information sent in the event payload on the CCAPI logs; transaction , which invokes another chaincode transactions when the event is received; and custom , which executes a custom function previously defined in the event. For the cc-tools-demo repository, there are 1 pre-defined event registered: Create Library Log The events definition is done in the chaincode/eventtypes folder Here follow the list of files: chaincode/ eventtypes/ # event folder createLibraryLog.go # definition of the library log event eventTypeList.go # list of events instantiated Event definition The construction and definition of an event is done by creating a file at chaincode/eventtypes folder An event has the following fields Tag : string field used to define the name of the event referenced internally by the code and by the rest-server clients. Label : string field to define the label to be used by external applications and the rest-server clients. Free text. Description : asset description string field to be used by external applications. Free text. BaseLog : string field with a message to be logged on the CCAPI at every event calling. Free text. EventType : defines the type of the event. Possible options being events.EventLog , events.EventTransaction and events.EventCustom . Transaction : string field with the tag of the transaction to be called by events of the transaction type. Channel : string field with the channel name of where the transaction to be called by an event of the transaction type is located. If empty, defaults to the same channel of the caller. Chaincode : string field with the chaincode name of where the transaction to be called by an event of the transaction type is located. If empty, defaults to the same chaincode of the caller. CustomFunction : a custom function to be executed by events of the custom type. It receives a stub of the type *sw.StubWrapper and a payload of type []byte , sent alongside the event, and returns an error. ReadOnly : a boolean which defines if the custom functions for events of type custom can alter the world state or not. If true , no assets will be able to be commited to the ledger by the custom function. Event example The cc-tools-demo repository has the following example: chaincode/ eventtypes/ # event folder createLibraryLog.go # definition of the library log event eventTypeList.go # list of events instantiated Besides the files of each event, you must register the events that can be used by the Goledger CC-Tools library in the eventTypeList.go file The definition of the CreateLibraryLog asset is as follows: var CreateLibraryLog = events.Event{ Tag: \"createLibraryLog\", Label: \"Create Library Log\", Description: \"Log of a library creation\", Type: events.EventLog, // Event funciton is to log on the CCAPI BaseLog: \"New library created\", // BaseLog is a base message to be logged Receivers: []string{\"$org2MSP\", \"$orgMSP\"}, // Receivers are the MSPs that will receive the event } According to the description above, the event CreateLibraryLog has the following characteristics: Is of log type, registering its messages on the CCAPI logs Every event of this type received will have the base message New library created logged on the CCAPI Only org2 and org will be registered to wait for events of this type Event list definition GoLedger CC-Tools events registration must be defined in the chaincode/eventTypeList.go file var eventTypeList = []events.Event{ eventtypes.CreateLibraryLog, } Calling the events CC-Tools event can be called from the transactions using the stub object provided and a []byte can be sent alongside it. For log events, the payload is a marshalled string: payload, ok := json.Marshal(\"the event payload\") For transaction events, the payload is a marshalled object containing the parameters for the called transaction: payload, ok := json.Marshal(map[string]interface{}{ \"library\": libraryAsset, }) For custom events the payload can be anything on the []byte format, to be handled accordingly by the custom function. It's possible to call events using the event object: eventObj.CallEvent(stub, payload) or using the event tag to trigger it: events.CallEvent(stub, \"createLibraryLog\", payload)","title":"Events"},{"location":"events/#events","text":"Hyperledger Fabric allows client applications (such as the rest-server API) to receive block events while block are commited to the peer's ledger. CC-Tools have a built-in event funcionality that allows for a quick register of the event, which will automatically be listened and handled by the standard CCAPI. The events in CC-Tools can be of three types: log , registering the information sent in the event payload on the CCAPI logs; transaction , which invokes another chaincode transactions when the event is received; and custom , which executes a custom function previously defined in the event. For the cc-tools-demo repository, there are 1 pre-defined event registered: Create Library Log The events definition is done in the chaincode/eventtypes folder Here follow the list of files: chaincode/ eventtypes/ # event folder createLibraryLog.go # definition of the library log event eventTypeList.go # list of events instantiated","title":"Events"},{"location":"events/#event-definition","text":"The construction and definition of an event is done by creating a file at chaincode/eventtypes folder An event has the following fields Tag : string field used to define the name of the event referenced internally by the code and by the rest-server clients. Label : string field to define the label to be used by external applications and the rest-server clients. Free text. Description : asset description string field to be used by external applications. Free text. BaseLog : string field with a message to be logged on the CCAPI at every event calling. Free text. EventType : defines the type of the event. Possible options being events.EventLog , events.EventTransaction and events.EventCustom . Transaction : string field with the tag of the transaction to be called by events of the transaction type. Channel : string field with the channel name of where the transaction to be called by an event of the transaction type is located. If empty, defaults to the same channel of the caller. Chaincode : string field with the chaincode name of where the transaction to be called by an event of the transaction type is located. If empty, defaults to the same chaincode of the caller. CustomFunction : a custom function to be executed by events of the custom type. It receives a stub of the type *sw.StubWrapper and a payload of type []byte , sent alongside the event, and returns an error. ReadOnly : a boolean which defines if the custom functions for events of type custom can alter the world state or not. If true , no assets will be able to be commited to the ledger by the custom function.","title":"Event definition"},{"location":"events/#event-example","text":"The cc-tools-demo repository has the following example: chaincode/ eventtypes/ # event folder createLibraryLog.go # definition of the library log event eventTypeList.go # list of events instantiated Besides the files of each event, you must register the events that can be used by the Goledger CC-Tools library in the eventTypeList.go file The definition of the CreateLibraryLog asset is as follows: var CreateLibraryLog = events.Event{ Tag: \"createLibraryLog\", Label: \"Create Library Log\", Description: \"Log of a library creation\", Type: events.EventLog, // Event funciton is to log on the CCAPI BaseLog: \"New library created\", // BaseLog is a base message to be logged Receivers: []string{\"$org2MSP\", \"$orgMSP\"}, // Receivers are the MSPs that will receive the event } According to the description above, the event CreateLibraryLog has the following characteristics: Is of log type, registering its messages on the CCAPI logs Every event of this type received will have the base message New library created logged on the CCAPI Only org2 and org will be registered to wait for events of this type","title":"Event example"},{"location":"events/#event-list-definition","text":"GoLedger CC-Tools events registration must be defined in the chaincode/eventTypeList.go file var eventTypeList = []events.Event{ eventtypes.CreateLibraryLog, }","title":"Event list definition"},{"location":"events/#calling-the-events","text":"CC-Tools event can be called from the transactions using the stub object provided and a []byte can be sent alongside it. For log events, the payload is a marshalled string: payload, ok := json.Marshal(\"the event payload\") For transaction events, the payload is a marshalled object containing the parameters for the called transaction: payload, ok := json.Marshal(map[string]interface{}{ \"library\": libraryAsset, }) For custom events the payload can be anything on the []byte format, to be handled accordingly by the custom function. It's possible to call events using the event object: eventObj.CallEvent(stub, payload) or using the event tag to trigger it: events.CallEvent(stub, \"createLibraryLog\", payload)","title":"Calling the events"},{"location":"external-tools/","text":"External Tools GoLedger CC-Tools library has a range of external tools that help immensely in the journey of developing a permissioned Blockchain based on Hyperledger Fabric cc-tools-demo - public repository with example assets and transactions using GoLedger CC-Tools library cc-webclient - docker image with web application to interconnect with Rest Api. GoFabric - network orchestration platform for production environments. https://gofabric.io cc-tools-demo Open repository with examples and transactions. The repository can be accessed as follows: git clone https://github.com/goledgerdev/cc-tools-demo.git cc-web-client Docker image providing web application for testing. The container can be instantiated as follows: docker run -p 0.0.0.0:8080:80/tcp --name cc-webclient goledger/cc-webclient:latest GoFabric GoFabric is a Hyperledger Fabric Blockchain orchestration platform fully compatible with GoLedger CC-Tools library The platform can be accessed at the following link: https://gofabric.io and has the following features: Deployment of cloud environment networks ( AWS, IBM, Azure, etc ) or on-premise Instantiate chaincodes ( compatibility with CC-Tools ) Update chaincodes Add or remove peers Add orderers Add orgs Instantiate or update Rest Servers Automatic code generation GoLedger Templates Community Join our community at Discord Discord Invite Link","title":"External Tools"},{"location":"external-tools/#external-tools","text":"GoLedger CC-Tools library has a range of external tools that help immensely in the journey of developing a permissioned Blockchain based on Hyperledger Fabric cc-tools-demo - public repository with example assets and transactions using GoLedger CC-Tools library cc-webclient - docker image with web application to interconnect with Rest Api. GoFabric - network orchestration platform for production environments. https://gofabric.io","title":"External Tools"},{"location":"external-tools/#cc-tools-demo","text":"Open repository with examples and transactions. The repository can be accessed as follows: git clone https://github.com/goledgerdev/cc-tools-demo.git","title":"cc-tools-demo"},{"location":"external-tools/#cc-web-client","text":"Docker image providing web application for testing. The container can be instantiated as follows: docker run -p 0.0.0.0:8080:80/tcp --name cc-webclient goledger/cc-webclient:latest","title":"cc-web-client"},{"location":"external-tools/#gofabric","text":"GoFabric is a Hyperledger Fabric Blockchain orchestration platform fully compatible with GoLedger CC-Tools library The platform can be accessed at the following link: https://gofabric.io and has the following features: Deployment of cloud environment networks ( AWS, IBM, Azure, etc ) or on-premise Instantiate chaincodes ( compatibility with CC-Tools ) Update chaincodes Add or remove peers Add orderers Add orgs Instantiate or update Rest Servers Automatic code generation GoLedger Templates","title":"GoFabric"},{"location":"external-tools/#community","text":"Join our community at Discord Discord Invite Link","title":"Community"},{"location":"functions/","text":"Functions Package description A complete description of GoLedger CC-Tools can be accessed at the following link: CCTools Pkg Description Asset functions Asset function list of GoLedger CC-Tools : CC-Tools Function List Types Types of GoLedger CC-Tools : CC-Tools Types","title":"Functions"},{"location":"functions/#functions","text":"","title":"Functions"},{"location":"functions/#package-description","text":"A complete description of GoLedger CC-Tools can be accessed at the following link: CCTools Pkg Description","title":"Package description"},{"location":"functions/#asset-functions","text":"Asset function list of GoLedger CC-Tools : CC-Tools Function List","title":"Asset functions"},{"location":"functions/#types","text":"Types of GoLedger CC-Tools : CC-Tools Types","title":"Types"},{"location":"getting-started/","text":"Getting Started GoLedger CC-Tools library was developed to be used in Linux operating system. In general we use the Ubuntu 18+ distribution, however the library is compatible with other environments, but some adjustments may be necessary. Download and setup To learn how to use GoLedger CC-Tools library , download the demo code repository available on GitHub . cd $HOME \\ git clone https://github.com/goledgerdev/cc-tools-demo.git \\ cd cc-tools-demo Folder distribution . // cc-tools-demo root folder | \u251c\u2500\u2500 ccapi // Rest API code (Golang Gin server) | \u251c\u2500\u2500 chaincode // Smart contract code (GoLang) | \u2514\u2500\u2500 assettypes // Asset definitions | \u2514\u2500\u2500 eventtypes // Asset definitions | \u2514\u2500\u2500 txdefs // Blockchain transactions | \u2514\u2500\u2500 datatypes // Custom property datatypes | \u251c\u2500\u2500 fabric // Hyperledger Fabric artifacts These are all the necessary elements to use the main functions of the library. Enviroment configuration The following systems, platforms and languages \u200b\u200bmust be installed: Docker 19+ GCC GoLang 1.14+ NodeJs 10+ Hyperledger Fabric 2.5 If you are using Linux Ubuntu , run the following command from the root directory. This will download and install the systems above before starting development. ./scripts/installPreReqUbuntu.sh At the end, the following success message should appear. Enviroment configured Now you're ready to Write Your First Application .","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"GoLedger CC-Tools library was developed to be used in Linux operating system. In general we use the Ubuntu 18+ distribution, however the library is compatible with other environments, but some adjustments may be necessary.","title":"Getting Started"},{"location":"getting-started/#download-and-setup","text":"To learn how to use GoLedger CC-Tools library , download the demo code repository available on GitHub . cd $HOME \\ git clone https://github.com/goledgerdev/cc-tools-demo.git \\ cd cc-tools-demo","title":"Download and setup"},{"location":"getting-started/#folder-distribution","text":". // cc-tools-demo root folder | \u251c\u2500\u2500 ccapi // Rest API code (Golang Gin server) | \u251c\u2500\u2500 chaincode // Smart contract code (GoLang) | \u2514\u2500\u2500 assettypes // Asset definitions | \u2514\u2500\u2500 eventtypes // Asset definitions | \u2514\u2500\u2500 txdefs // Blockchain transactions | \u2514\u2500\u2500 datatypes // Custom property datatypes | \u251c\u2500\u2500 fabric // Hyperledger Fabric artifacts These are all the necessary elements to use the main functions of the library.","title":"Folder distribution"},{"location":"getting-started/#enviroment-configuration","text":"The following systems, platforms and languages \u200b\u200bmust be installed: Docker 19+ GCC GoLang 1.14+ NodeJs 10+ Hyperledger Fabric 2.5 If you are using Linux Ubuntu , run the following command from the root directory. This will download and install the systems above before starting development. ./scripts/installPreReqUbuntu.sh At the end, the following success message should appear. Enviroment configured Now you're ready to Write Your First Application .","title":"Enviroment configuration"},{"location":"testing/","text":"Testing GoLedger CC-Tools has different ways for testing the source code in development mode. For GoLang syntax checking, execute the following command: cd chaincode \\ go vet After the succesfull code instantiation or update, you can check the logs directly inside the chaincode execution peers containers. These containers can be identified by starting with dev . docker logs dev-peer0.org1.example.com-cc-tools-demo-0.1 Using cc-webclient To perform the tests and integrations satisfactorily, it is suggested the usage of cc-webclient tool. After finishing the steps, it is suggested to execute the following commands to create 3 applications in order to connect with org1, org2 and org3 . ./run-cc-web.sh 8080 & \\ ./run-cc-web.sh 8090 & \\ ./run-cc-web.sh 8100 & Configuring rest-server and cc-webclient After executing cc-webclient containers, the applications can be accessed directly through the ports defined in the script. E.g.: 8080, 8090, 8100 After accessing cc-webclient through the browser, the configuration of rest server address can be done by clicking on the tool icon. Accesses are can be made with the following settings: org1 : http://localhost:80 org2 : http://localhost:980 org3 : http://localhost:1080 cc-webclient application has a sidebar that shows the available assets as well as the transactions registered in the chaincode. Endpoint usage The rest-server endpoint usage is shown using the CURL buttons. For each screen, you can check endpoint usage pressing the curl button. For example, on the asset creation screen: List, create, edit, delete or history an asset To list each asset, just select an asset in the sidebar. Selecting the CREATE button at the asset list window, an asset creation screen will appear. For example, for the Person asset The edit screen is accessed by selecting the edit icon in an asset's list window. The removal of an asset is requested by selecting the delete icon in the asset's list window. The history of an asset (all changes recorded in the ledger) can be viewed by selecting the history icon in an asset's window. Executing an transaction The transaction execution can be performed by selecting the transaction in the sidebar. For example, for transaction UpdateBookTenant Using Godog Godog is the official Cucumber BDD framework for Golang. It follows the principles of BDD, which emphasizes defining the desired behavior of the software through user-focused scenarios written in natural language. These scenarios are written in a Given-When-Then format, making it easier for non-technical team members to understand and contribute to the testing process. For the cc-tools-demo repository, there are godog tests for every transaction. Each transaction is represented as a feature and each feature has scenarios to be tested. Features are defined in chaincode/tests/features folder. chaincode/ tests/ features/ createNewLibrary.feature # definition of Create New Library feature getBooksByAuthor.feature # definition of Get Books By Author feature getNumberOfBooksFromLibrary.feature # definition of Get Number Of Books From Library feature updateBookTenant.feature # definition of Create New Library feature request_test.go # implementation of steps for scenarios Feature definition In the feature file, you start by defining the feature using the Feature keyword followed by a brief description. Each scenario within the feature is defined using the Scenario keyword, followed by a scenario title or description. Scenarios represent specific use cases or situations that you want to test. Inside each scenario, you define the steps of the test using Given , When , and Then keywords. These steps describe the preconditions (Given), actions (When), and expected outcomes (Then) of the scenario. Optionally, you can also use And and But to further clarify or add additional steps. See more on Godog/Cucumber . Feature examples The definition of Create New Library feature is as follows: Feature: Create New Library In order to create a new library As an API client I want to make a request with the name of the desired library Scenario: Create a new library Given there is a running \"\" test network from scratch When I make a \"POST\" request to \"/api/invoke/createNewLibrary\" on port 880 with: \"\"\" { \"name\": \"Elizabeth's Library\" } \"\"\" Then the response code should be 200 And the response should have: \"\"\" { \"@key\": \"library:9cf6726a-a327-568a-baf1-5881393073bf\", \"@lastTouchBy\": \"orgMSP\", \"@lastTx\": \"createNewLibrary\", \"@assetType\": \"library\", \"name\": \"Elizabeth's Library\" } \"\"\" Scenario: Try to create a new library with a name that already exists Given there is a running \"\" test network Given there is a library with name \"John's Library\" When I make a \"POST\" request to \"/api/invoke/createNewLibrary\" on port 880 with: \"\"\" { \"name\": \"John's Library\" } \"\"\" Then the response code should be 409 This feature tests the ability to create a new library using the createNewLibrary tx through the API. It consists of two scenarios: one is a successful case, and the other tests when attempting to create a library with a name that already exists. Scenario 1: This scenario represents the successful creation of a new library. It verifies that the API can correctly handle the request with a new library name and returns the expected response. Scenario 2: This scenario tests the case when attempting to create a library with a name that already exists in the system. It checks whether the API responds with the appropriate status code (409) to indicate a conflict. The definition of Get Books By Author feature is as follows: Feature: Get Books By Author In order to get all the books by an author As an API client I want to make a request to the getBooksByAuthor transaction And receive the appropriate books Scenario: Request an author with multiple books Given there is a running \"\" test network And there are 3 books with prefix \"book\" by author \"Jack\" When I make a \"GET\" request to \"/api/query/getBooksByAuthor\" on port 880 with: \"\"\" { \"authorName\": \"Jack\" } \"\"\" Then the response code should be 200 And the \"result\" field should have size 3 Scenario: Request an author with no books Given there is a running \"\" test network When I make a \"GET\" request to \"/api/query/getBooksByAuthor\" on port 880 with: \"\"\" { \"authorName\": \"Mary\" } \"\"\" Then the response code should be 200 And the \"result\" field should have size 0 Scenario: Request an author with 2 books while there are other authors with more books Given there is a running \"\" test network Given there are 1 books with prefix \"fantasy\" by author \"Missy\" Given there are 2 books with prefix \"cook\" by author \"John\" When I make a \"GET\" request to \"/api/query/getBooksByAuthor\" on port 880 with: \"\"\" { \"authorName\": \"John\" } \"\"\" Then the response code should be 200 And the \"result\" field should have size 2 This feature tests the ability to retrieve books written by a specific author using the getBooksByAuthor transaction through the API. It consists of three scenarios that cover different cases based on the number of books by the requested author. Scenario 1: This scenario verifies that the API can successfully handle a request for an author who has multiple books in the system. It checks whether the API returns the correct response code (200) and that the \"result\" field in the response contains all the books by the author with a size of 3. Scenario 2: This scenario tests the case when requesting an author who has no books in the system. It checks whether the API returns the appropriate response code (200) and that the \"result\" field in the response is empty with a size of 0. Scenario 3: This scenario validates the API's response when requesting an author with two books, while other authors have more books in the system. It verifies whether the API returns the correct response code (200) and that the \"result\" field contains the two books by the requested author with a size of 2. The definition of Get Number Of Books From Library feature is as follows: Feature: Get Number Of Books From Library In order to create the number of books from library As an API client I want to make a request Scenario: Query Get Number Of Books From Library that Exists Given there is a running \"\" test network And I make a \"POST\" request to \"/api/invoke/createAsset\" on port 880 with: \"\"\" { \"asset\": [ { \"@assetType\": \"book\", \"title\": \"Meu Nome \u00e9 Maria\", \"author\": \"Maria Viana\" } ] } \"\"\" And I make a \"POST\" request to \"/api/invoke/createAsset\" on port 880 with: \"\"\" { \"asset\": [{ \"@assetType\": \"library\", \"name\": \"Maria's Library\", \"books\": [ { \"@assetType\": \"book\", \"@key\": \"book:a36a2920-c405-51c3-b584-dcd758338cb5\" } ] }] } \"\"\" When I make a \"GET\" request to \"/api/query/getNumberOfBooksFromLibrary\" on port 880 with: \"\"\" { \"library\": { \"@key\": \"library:3cab201f-9e2b-579d-b7b2-72297ed17f49\", \"@assetType\": \"library\" } } \"\"\" Then the response code should be 200 And the response should have: \"\"\" { \"numberOfBooks\": 1.0 } \"\"\" Scenario: Query Get Number Of Books From Library that Does Not Exists Given there is a running \"\" test network When I make a \"GET\" request to \"/api/query/getNumberOfBooksFromLibrary\" on port 880 with: \"\"\" { \"library\": { \"@key\": \"library:5c5b201f-9e4c-579d-b7b2-72297ed17f78\", \"@assetType\": \"library\" } } \"\"\" Then the response code should be 400 This feature tests the ability to retrieve the number of books from a library through the API. It consists of two scenarios: one scenario deals with querying a library that exists and has books, while the other scenario tests querying a library that does not exist. Scenario 1: This scenario verifies that the API can successfully retrieve the number of books from a library that exists in the system. It first creates a new book and a library with the book associated. Then it queries the number of books from the library and checks whether the API returns the correct response code (200) and whether the response contains the expected number of books (1). Scenario 2: This scenario tests the case when attempting to query the number of books from a library that does not exist in the system. It checks whether the API returns the appropriate response code (400) to indicate a bad request due to the non-existent library. The definition of Update Book Tentant feature is as follows: Feature: Update Book Tentant In order to update book tentant As an API client I want to make a request Scenario: Update Book With A Existing Tentant # The first 3 statements will be used by all scenarios on this feature Given there is a running \"\" test network And I make a \"POST\" request to \"/api/invoke/createAsset\" on port 880 with: \"\"\" { \"asset\": [{ \"@assetType\": \"book\", \"title\": \"Meu Nome \u00e9 Maria\", \"author\": \"Maria Viana\" }] } \"\"\" And I make a \"POST\" request to \"/api/invoke/createAsset\" on port 880 with: \"\"\" { \"asset\": [{ \"@assetType\": \"person\", \"name\": \"Maria\", \"id\": \"31820792048\" }] } \"\"\" When I make a \"PUT\" request to \"/api/invoke/updateBookTenant\" on port 880 with: \"\"\" { \"book\": { \"@assetType\": \"book\", \"@key\": \"book:a36a2920-c405-51c3-b584-dcd758338cb5\" }, \"tenant\": { \"@assetType\": \"person\", \"@key\": \"person:47061146-c642-51a1-844a-bf0b17cb5e19\" } } \"\"\" Then the response code should be 200 And the response should have: \"\"\" { \"@key\": \"book:a36a2920-c405-51c3-b584-dcd758338cb5\", \"@lastTouchBy\": \"orgMSP\", \"@lastTx\": \"updateBookTenant\", \"currentTenant\": { \"@assetType\": \"person\", \"@key\": \"person:47061146-c642-51a1-844a-bf0b17cb5e19\" } } \"\"\" Scenario: Update Book With A Not Existing Tentant Given there is a running \"\" test network When I make a \"PUT\" request to \"/api/invoke/updateBookTenant\" on port 880 with: \"\"\" { \"book\": { \"@assetType\": \"book\", \"@key\": \"book:a36a2920-c405-51c3-b584-dcd758338cb5\" }, \"tenant\": { \"@assetType\": \"person\", \"@key\": \"person:56891146-c6866-51a1-844a-bf0b17cb5e19\" } } \"\"\" Then the response code should be 404 This feature tests the ability to update the tenant of a book using the API. It consists of two scenarios: one scenario deals with updating a book with an existing tenant, and the other scenario tests updating a book with a non-existent tenant. Scenario 1: This scenario verifies that the API can successfully update the tenant of a book with an existing tenant. It creates a new book and a new person (tenant), associates the person with the book, and then makes a PUT request to update the book's tenant. The scenario checks whether the API returns the correct response code (200) and whether the book's tenant is correctly updated in the response. Scenario 2: This scenario tests the case when attempting to update the tenant of a book with a tenant that does not exist in the system. It makes a PUT request to update the book's tenant with the non-existing tenant. The scenario checks whether the API returns the appropriate response code (404) to indicate that the tenant does not exist in the system. Implementation of steps Each step is implemented in chaincode/tests/request_test.go file. For Given there is a running \"\" test network from scratch there is the following implementation: func thereIsARunningTestNetworkFromScratch(arg1 string) error { // Start test network with 1 org only cmd := exec.Command(\"../../startDev.sh\", \"-n\", \"1\") _, err := cmd.Output() if err != nil { fmt.Println(err.Error()) return err } // Wait for ccapi err = waitForNetwork(\"880\") if err != nil { fmt.Println(err.Error()) return err } return nil } This function starts a test network from scratch with a single organization. It executes a shell command ../../startDev.sh -n 1 to start the test network. After starting the network, it waits for the ccapi to be available on port 880 using the waitForNetwork function. For When I make a \"[method]\" request to \"[endpoint]\" on port [port] with \"[body]\" there is the following implementation: func iMakeARequestToOnPortWith(ctx context.Context, method, endpoint string, port int, reqBody *godog.DocString) (context.Context, error) { var res *http.Response var req *http.Request var err error // Initialize http client client := &http.Client{} // Create request if method == \"GET\" { b64str := b64.StdEncoding.EncodeToString([]byte(reqBody.Content)) reqParam := \"?@request=\" + b64str req, err = http.NewRequest(\"GET\", \"http://localhost:\"+strconv.Itoa(port)+endpoint+reqParam, nil) if err != nil { return ctx, err } } else { dataAsBytes := bytes.NewBuffer([]byte(reqBody.Content)) req, err = http.NewRequest(method, \"http://localhost:\"+strconv.Itoa(port)+endpoint, dataAsBytes) if err != nil { return ctx, err } } // Set header and make request req.Header.Set(\"Content-Type\", \"application/json\") res, err = client.Do(req) if err != nil { return ctx, err } // Get status code and response body statusCode := res.StatusCode resBody, err := ioutil.ReadAll(res.Body) if err != nil { return ctx, err } res.Body.Close() // Append status code and response body to context bodyCtx := context.WithValue(ctx, bodyCtxKey{}, resBody) statusCtx := context.WithValue(bodyCtx, statusCtxKey{}, statusCode) return statusCtx, nil } This function makes an HTTP request to a specified endpoint on a given port. The function supports both GET and POST methods. If the method is GET , the request body is base64 encoded and added as a query parameter. If the method is POST , the request body is included in the request as JSON data. For Then the response code should be [code] there is the following implementation: func theResponseCodeShouldBe(ctx context.Context, expectedCode int) (context.Context, error) { // Get Status Code from context statusCode, ok := ctx.Value(statusCtxKey{}).(int) if !ok { return ctx, errors.New(\"context unaveilable while retrieving status\") } if statusCode != expectedCode { // Get Response body from context resBody, ok := ctx.Value(bodyCtxKey{}).([]byte) if !ok { return ctx, errors.New(\"unaveilable context while retrieving body\") } // Test Failed return ctx, fmt.Errorf(\"received wrong status response. Got %d Expected: %d\\nResponse body: %s\", statusCode, expectedCode, string(resBody)) } return ctx, nil } This function checks whether the received HTTP response status code matches the expected code. For And the response should have there is the following implementation: func theResponseShouldHave(ctx context.Context, body *godog.DocString) error { // Get 'ResponseBody' from context respBody, ok := ctx.Value(bodyCtxKey{}).([]byte) if !ok { return errors.New(\"unavailable context\") } var expected map[string]interface{} var received map[string]interface{} if err := json.Unmarshal([]byte(body.Content), &expected); err != nil { return err } if err := json.Unmarshal(respBody, &received); err != nil { return err } for key, value := range expected { if !reflect.DeepEqual(value, received[key]) { var expectedBytes []byte var receivedBytes []byte var err error if expectedBytes, err = json.MarshalIndent(value, \"\", \" \"); err != nil { return err } if receivedBytes, err = json.MarshalIndent(received[key], \"\", \" \"); err != nil { return err } return fmt.Errorf(\"Expected %s to be equal %s, but received %s\", key, expectedBytes, receivedBytes) } } return nil } This function checks if the received HTTP response body matches the expected response body defined in the Godog scenario step. It first retrieves the actual response body and the expected response body from the context. It unmarshals both JSON strings into corresponding map-like structures to facilitate comparison. The function performs a deep comparison between the value of each key in the expected and received response bodies using reflect.DeepEqual function. For And the \"[field]\" field should have size [size] there is the following implementation: func theFieldShouldHaveSize(ctx context.Context, field string, expectedSize int) (context.Context, error) { // Get 'ResponseBody' from context respBody, ok := ctx.Value(bodyCtxKey{}).([]byte) if !ok { return ctx, errors.New(\"unavailable context\") } var bodyMap map[string]interface{} if err := json.Unmarshal(respBody, &bodyMap); err != nil { return ctx, err } resultField, ok := bodyMap[field] if !ok { return ctx, errors.New(\"unavailable filed on body response\") } fieldLen := len(resultField.([]interface{})) if fieldLen != expectedSize { // Test Failed return ctx, fmt.Errorf(\"received wrong filed size on response body. Got %d Expected: %d\\nResponse body: %s\", fieldLen, expectedSize, string(respBody)) } return ctx, nil } This function is used to check if a specific field in the received JSON response body has the expected size (number of elements). It is typically used in Godog scenarios to verify the size of an array or a list-like field in the response. For And there are [number] books with prefix \"[prefix]\" by author \"[name]\" there is the following implementation: func thereAreBooksWithPrefixByAuthor(ctx context.Context, nBooks int, prefix string, author string) (context.Context, error) { var res *http.Response var err error for i := 1; i <= nBooks; i++ { // Verify if book already exists requestJSON := map[string]interface{}{ \"query\": map[string]interface{}{ \"selector\": map[string]interface{}{ \"author\": author, \"title\": prefix + strconv.Itoa(i), \"@assetType\": \"book\", }, }, \"resolve\": true, } jsonStr, e := json.Marshal(requestJSON) if e != nil { return ctx, err } dataAsBytes := bytes.NewBuffer([]byte(jsonStr)) if res, err = http.Post(\"http://localhost/api/query/search\", \"application/json\", dataAsBytes); err != nil { return ctx, err } resBody, err := ioutil.ReadAll(res.Body) if err != nil { return ctx, err } res.Body.Close() var received map[string]interface{} if err = json.Unmarshal(resBody, &received); err != nil { return ctx, err } // Create book if it doesnt exists if len(received[\"result\"].([]interface{})) == 0 { requestJSON := map[string]interface{}{ \"asset\": []interface{}{ map[string]interface{}{ \"author\": author, \"title\": prefix + strconv.Itoa(i), \"@assetType\": \"book\", }, }, } jsonStr, e := json.Marshal(requestJSON) if e != nil { return ctx, err } dataAsBytes := bytes.NewBuffer([]byte(jsonStr)) if res, err = http.Post(\"http://localhost:880/api/invoke/createAsset\", \"application/json\", dataAsBytes); err != nil { return ctx, err } if res.StatusCode != 200 { return ctx, errors.New(\"Failed to create book asset\") } } } return ctx, nil } This function is used to ensure that there are a specific number of books with a given prefix and author in the system. It is typically used in Godog scenarios to set up the required test data before running tests that involve books and authors. For Given there is a library with name \"[name]\" there is the following implementation: func thereIsALibraryWithName(ctx context.Context, name string) (context.Context, error) { var res *http.Response var err error // Verify if library already exists requestJSON := map[string]interface{}{ \"query\": map[string]interface{}{ \"selector\": map[string]interface{}{ \"name\": name, \"@assetType\": \"library\", }, }, \"resolve\": true, } jsonStr, e := json.Marshal(requestJSON) if e != nil { return ctx, err } dataAsBytes := bytes.NewBuffer([]byte(jsonStr)) if res, err = http.Post(\"http://localhost/api/query/search\", \"application/json\", dataAsBytes); err != nil { return ctx, err } resBody, err := ioutil.ReadAll(res.Body) if err != nil { return ctx, err } res.Body.Close() var received map[string]interface{} if err = json.Unmarshal(resBody, &received); err != nil { return ctx, err } // Create library if it doesnt exists if len(received[\"result\"].([]interface{})) == 0 { requestJSON = map[string]interface{}{ \"asset\": []interface{}{ map[string]interface{}{ \"name\": name, \"@assetType\": \"library\", }, }, } jsonStr, e = json.Marshal(requestJSON) if e != nil { return ctx, err } dataAsBytes = bytes.NewBuffer([]byte(jsonStr)) if res, err = http.Post(\"http://localhost:880/api/invoke/createAsset\", \"application/json\", dataAsBytes); err != nil { return ctx, err } if res.StatusCode != 200 { return ctx, errors.New(\"Failed to create library asset\") } } return ctx, nil } This function is used to ensure that a library with a specific name exists in the system. It is typically used in Godog scenarios to set up the required test data before running tests that involve libraries. If the library does not exist, it creates a new library asset. It's required to initialize the scenario with the implementation of each step. The function below describes how to do it: func InitializeScenario(ctx *godog.ScenarioContext) { ctx.Step(`^I make a \"([^\"]*)\" request to \"([^\"]*)\" on port (\\d+) with:$`, iMakeARequestToOnPortWith) ctx.Step(`^the response code should be (\\d+)$`, theResponseCodeShouldBe) ctx.Step(`^the response should have:$`, theResponseShouldHave) ctx.Step(`^there is a running \"([^\"]*)\" test network$`, thereIsARunningTestNetwork) ctx.Step(`^there is a running \"([^\"]*)\" test network from scratch$`, thereIsARunningTestNetworkFromScratch) ctx.Step(`^there are (\\d+) books with prefix \"([^\"]*)\" by author \"([^\"]*)\"$`, thereAreBooksWithPrefixByAuthor) ctx.Step(`^the \"([^\"]*)\" field should have size (\\d+)$`, theFieldShouldHaveSize) ctx.Step(`^there is a library with name \"([^\"]*)\"$`, thereIsALibraryWithName) } Run Godog tests Begin by installing godog using the following command: $ go install github.com/cucumber/godog/cmd/godog@latest Once godog is successfully installed, utilize the provided script to run tests effortlessly: $ ./godog.sh Using Golang testing It's also possible to test the developed transactions using Golang testing library. In this type of testing you can simulate a transaction call and compare its results to an expected value. It's important to note that this type of testing does not work on transactions that reads the chaincode state database (such as using couchdb queries) nor transactions that reads an asset history. For the cc-tools-demo repository, there are tests for the createNewLibrary , getNumberOfBooksFromLibrary and updateBookTenant transactions. The tests are defined in the chaincode/ folder. chaincode/ main_test.go // setup the test enviroment txdefs_createNewLibrary_test.go // tests the createNewLibrary transaction txdefs_getNumberOfBooksFromLibrary_test.go // tests the getNumberOfBooksFromLibrary transaction txdefs_updateBookTenant_test.go // tests the updateBookTenant transaction Test examples The definition of Create New Library test is as follows: func TestCreateNewLibrary(t *testing.T) { stub := mock.NewMockStub(\"org3MSP\", new(cc.CCDemo)) expectedResponse := map[string]interface{}{ \"@key\": \"library:3cab201f-9e2b-579d-b7b2-72297ed17f49\", \"@lastTouchBy\": \"org3MSP\", \"@lastTx\": \"createNewLibrary\", \"@assetType\": \"library\", \"name\": \"Maria's Library\", } req := map[string]interface{}{ \"name\": \"Maria's Library\", } reqBytes, err := json.Marshal(req) if err != nil { t.FailNow() } res := stub.MockInvoke(\"createNewLibrary\", [][]byte{ []byte(\"createNewLibrary\"), reqBytes, }) expectedResponse[\"@lastUpdated\"] = stub.TxTimestamp.AsTime().Format(time.RFC3339) if res.GetStatus() != 200 { log.Println(res) t.FailNow() } var resPayload map[string]interface{} err = json.Unmarshal(res.GetPayload(), &resPayload) if err != nil { log.Println(err) t.FailNow() } if !reflect.DeepEqual(resPayload, expectedResponse) { log.Println(\"these should be equal\") log.Printf(\"%#v\\n\", resPayload) log.Printf(\"%#v\\n\", expectedResponse) t.FailNow() } var state map[string]interface{} stateBytes := stub.State[\"library:3cab201f-9e2b-579d-b7b2-72297ed17f49\"] err = json.Unmarshal(stateBytes, &state) if err != nil { log.Println(err) t.FailNow() } if !reflect.DeepEqual(state, expectedResponse) { log.Println(\"these should be equal\") log.Printf(\"%#v\\n\", state) log.Printf(\"%#v\\n\", expectedResponse) t.FailNow() } } The following steps occur on this test: - A mock stub for org3 is created - The objects with the expected response for the createNewLibrary transaction and the transaction request are created - The createNewLibrary transaction is invoked using the request defined on the previous step - The timestamp from the stub is added to the expectedResponse object - The status of the invoke is checked for the 200 code - A deep compare is made between the expected response object and the invoke response - The state for the key of the created object in the stub is also compared to the expected response The definition of Get Number Of Books From Library test is as follows: func TestGetNumberOfBooksFromLibrary(t *testing.T) { stub := mock.NewMockStub(\"org2MSP\", new(CCDemo)) // Setup state setupBook := map[string]interface{}{ \"@key\": \"book:a36a2920-c405-51c3-b584-dcd758338cb5\", \"@lastTouchBy\": \"org2MSP\", \"@lastTx\": \"createAsset\", \"@assetType\": \"book\", \"title\": \"Meu Nome \u00e9 Maria\", \"author\": \"Maria Viana\", \"genres\": []interface{}{\"biography\", \"non-fiction\"}, \"published\": \"2019-05-06T22:12:41Z\", } setupLibrary := map[string]interface{}{ \"@key\": \"library:3cab201f-9e2b-579d-b7b2-72297ed17f49\", \"@lastTouchBy\": \"org3MSP\", \"@lastTx\": \"createNewLibrary\", \"@assetType\": \"library\", \"name\": \"Maria's Library\", \"books\": []map[string]interface{}{ { \"@assetType\": \"book\", \"@key\": \"book:a36a2920-c405-51c3-b584-dcd758338cb5\", }, }, } setupBookJSON, _ := json.Marshal(setupBook) setupLibraryJSON, _ := json.Marshal(setupLibrary) stub.MockTransactionStart(\"setupGetNumberOfBooksFromLibrary\") stub.PutState(\"book:a36a2920-c405-51c3-b584-dcd758338cb5\", setupBookJSON) stub.PutState(\"library:3cab201f-9e2b-579d-b7b2-72297ed17f49\", setupLibraryJSON) refIdx, err := stub.CreateCompositeKey(\"book:a36a2920-c405-51c3-b584-dcd758338cb5\", []string{\"library:3cab201f-9e2b-579d-b7b2-72297ed17f49\"}) if err != nil { log.Println(err) t.FailNow() } stub.PutState(refIdx, []byte{0x00}) stub.MockTransactionEnd(\"setupGetNumberOfBooksFromLibrary\") expectedResponse := map[string]interface{}{ \"numberOfBooks\": 1.0, } req := map[string]interface{}{ \"library\": map[string]interface{}{ \"name\": \"Maria's Library\", }, } reqBytes, err := json.Marshal(req) if err != nil { t.FailNow() } res := stub.MockInvoke(\"getNumberOfBooksFromLibrary\", [][]byte{ []byte(\"getNumberOfBooksFromLibrary\"), reqBytes, }) if res.GetStatus() != 200 { log.Println(res) t.FailNow() } var resPayload map[string]interface{} err = json.Unmarshal(res.GetPayload(), &resPayload) if err != nil { log.Println(err) t.FailNow() } if !reflect.DeepEqual(resPayload, expectedResponse) { log.Println(\"these should be equal\") log.Printf(\"%#v\\n\", resPayload) log.Printf(\"%#v\\n\", expectedResponse) t.FailNow() } } The following steps occur on this test: - A mock stub for org2 is created - The state objects for the book and the library are defined and added to the mock state on the stub - The objects with the expected response for the getNumberOfBooksFromLibrary transaction and the transaction request are created - The getNumberOfBooksFromLibrary transaction is invoked using the request defined on the previous step - The status of the invoke is checked for the 200 code - A deep compare is made between the expected response object and the invoke response The definition of Update Book Tenant test is as follows: func TestUpdateBookTenant(t *testing.T) { stub := mock.NewMockStub(\"org1MSP\", new(CCDemo)) // State setup setupPerson := map[string]interface{}{ \"@key\": \"person:47061146-c642-51a1-844a-bf0b17cb5e19\", \"@lastTouchBy\": \"org1MSP\", \"@lastTx\": \"createAsset\", \"@assetType\": \"person\", \"name\": \"Maria\", \"id\": \"31820792048\", \"height\": 0.0, } setupBook := map[string]interface{}{ \"@key\": \"book:a36a2920-c405-51c3-b584-dcd758338cb5\", \"@lastTouchBy\": \"org2MSP\", \"@lastTx\": \"createAsset\", \"@assetType\": \"book\", \"title\": \"Meu Nome \u00e9 Maria\", \"author\": \"Maria Viana\", // \"currentTenant\": map[string]interface{}{ // \"@assetType\": \"person\", // \"@key\": \"person:47061146-c642-51a1-844a-bf0b17cb5e19\", // }, \"genres\": []interface{}{\"biography\", \"non-fiction\"}, \"published\": \"2019-05-06T22:12:41Z\", } setupPersonJSON, _ := json.Marshal(setupPerson) setupBookJSON, _ := json.Marshal(setupBook) stub.MockTransactionStart(\"setupUpdateBookTenant\") stub.PutState(\"person:47061146-c642-51a1-844a-bf0b17cb5e19\", setupPersonJSON) stub.PutState(\"book:a36a2920-c405-51c3-b584-dcd758338cb5\", setupBookJSON) stub.MockTransactionEnd(\"setupUpdateBookTenant\") req := map[string]interface{}{ \"book\": map[string]interface{}{ \"@key\": \"book:a36a2920-c405-51c3-b584-dcd758338cb5\", }, \"tenant\": map[string]interface{}{ \"@key\": \"person:47061146-c642-51a1-844a-bf0b17cb5e19\", }, } reqBytes, _ := json.Marshal(req) res := stub.MockInvoke(\"updateBookTenant\", [][]byte{ []byte(\"updateBookTenant\"), reqBytes, }) if res.GetStatus() != 200 { log.Println(res) t.FailNow() } var resPayload map[string]interface{} err := json.Unmarshal(res.GetPayload(), &resPayload) if err != nil { log.Println(err) t.FailNow() } expectedResponse := map[string]interface{}{ \"@key\": \"book:a36a2920-c405-51c3-b584-dcd758338cb5\", \"@lastTouchBy\": \"org1MSP\", \"@lastTx\": \"updateBookTenant\", \"@assetType\": \"book\", \"title\": \"Meu Nome \u00e9 Maria\", \"author\": \"Maria Viana\", \"currentTenant\": map[string]interface{}{ \"@assetType\": \"person\", \"@key\": \"person:47061146-c642-51a1-844a-bf0b17cb5e19\", }, \"genres\": []interface{}{\"biography\", \"non-fiction\"}, \"published\": \"2019-05-06T22:12:41Z\", } expectedResponse[\"@lastUpdated\"] = stub.TxTimestamp.AsTime().Format(time.RFC3339) if !reflect.DeepEqual(resPayload, expectedResponse) { log.Println(\"these should be equal\") log.Printf(\"%#v\\n\", resPayload) log.Printf(\"%#v\\n\", expectedResponse) t.FailNow() } var state map[string]interface{} stateBytes := stub.State[\"book:a36a2920-c405-51c3-b584-dcd758338cb5\"] err = json.Unmarshal(stateBytes, &state) if err != nil { log.Println(err) t.FailNow() } if !reflect.DeepEqual(state, expectedResponse) { log.Println(\"these should be equal\") log.Printf(\"%#v\\n\", state) log.Printf(\"%#v\\n\", expectedResponse) t.FailNow() } } The following steps occur on this test: - A mock stub for org1 is created - The state objects for the book and the person are defined and added to the mock state on the stub - The object with the request for the updateBookTenant transaction is created - The status of the invoke is checked for the 200 code - The expected response object is created, with the stub timestamp added to the @lastUpdated value - A deep compare is made between the expected response object and the invoke response - The state for the key of the book in the stub is also compared to the expected response Running the tests To run the tests, execute the following command: cd chaincode && \\ go test && \\ cd .. If the tests were succeseful, the following messages should appear on the terminal: main.go:131: 200 init 40.796\u00b5s main.go:131: 200 getNumberOfBooksFromLibrary 31.298\u00b5s main.go:131: 200 updateBookTenant 136.09\u00b5s main.go:131: 200 createNewLibrary 60.794\u00b5s PASS ok github.com/goledgerdev/cc-tools-demo/chaincode 0.006s","title":"Testing"},{"location":"testing/#testing","text":"GoLedger CC-Tools has different ways for testing the source code in development mode. For GoLang syntax checking, execute the following command: cd chaincode \\ go vet After the succesfull code instantiation or update, you can check the logs directly inside the chaincode execution peers containers. These containers can be identified by starting with dev . docker logs dev-peer0.org1.example.com-cc-tools-demo-0.1","title":"Testing"},{"location":"testing/#using-cc-webclient","text":"To perform the tests and integrations satisfactorily, it is suggested the usage of cc-webclient tool. After finishing the steps, it is suggested to execute the following commands to create 3 applications in order to connect with org1, org2 and org3 . ./run-cc-web.sh 8080 & \\ ./run-cc-web.sh 8090 & \\ ./run-cc-web.sh 8100 &","title":"Using cc-webclient"},{"location":"testing/#configuring-rest-server-and-cc-webclient","text":"After executing cc-webclient containers, the applications can be accessed directly through the ports defined in the script. E.g.: 8080, 8090, 8100 After accessing cc-webclient through the browser, the configuration of rest server address can be done by clicking on the tool icon. Accesses are can be made with the following settings: org1 : http://localhost:80 org2 : http://localhost:980 org3 : http://localhost:1080 cc-webclient application has a sidebar that shows the available assets as well as the transactions registered in the chaincode.","title":"Configuring rest-server and cc-webclient"},{"location":"testing/#endpoint-usage","text":"The rest-server endpoint usage is shown using the CURL buttons. For each screen, you can check endpoint usage pressing the curl button. For example, on the asset creation screen:","title":"Endpoint usage"},{"location":"testing/#list-create-edit-delete-or-history-an-asset","text":"To list each asset, just select an asset in the sidebar. Selecting the CREATE button at the asset list window, an asset creation screen will appear. For example, for the Person asset The edit screen is accessed by selecting the edit icon in an asset's list window. The removal of an asset is requested by selecting the delete icon in the asset's list window. The history of an asset (all changes recorded in the ledger) can be viewed by selecting the history icon in an asset's window.","title":"List, create, edit, delete or history an asset"},{"location":"testing/#executing-an-transaction","text":"The transaction execution can be performed by selecting the transaction in the sidebar. For example, for transaction UpdateBookTenant","title":"Executing an transaction"},{"location":"testing/#using-godog","text":"Godog is the official Cucumber BDD framework for Golang. It follows the principles of BDD, which emphasizes defining the desired behavior of the software through user-focused scenarios written in natural language. These scenarios are written in a Given-When-Then format, making it easier for non-technical team members to understand and contribute to the testing process. For the cc-tools-demo repository, there are godog tests for every transaction. Each transaction is represented as a feature and each feature has scenarios to be tested. Features are defined in chaincode/tests/features folder. chaincode/ tests/ features/ createNewLibrary.feature # definition of Create New Library feature getBooksByAuthor.feature # definition of Get Books By Author feature getNumberOfBooksFromLibrary.feature # definition of Get Number Of Books From Library feature updateBookTenant.feature # definition of Create New Library feature request_test.go # implementation of steps for scenarios","title":"Using Godog"},{"location":"testing/#feature-definition","text":"In the feature file, you start by defining the feature using the Feature keyword followed by a brief description. Each scenario within the feature is defined using the Scenario keyword, followed by a scenario title or description. Scenarios represent specific use cases or situations that you want to test. Inside each scenario, you define the steps of the test using Given , When , and Then keywords. These steps describe the preconditions (Given), actions (When), and expected outcomes (Then) of the scenario. Optionally, you can also use And and But to further clarify or add additional steps. See more on Godog/Cucumber .","title":"Feature definition"},{"location":"testing/#feature-examples","text":"The definition of Create New Library feature is as follows: Feature: Create New Library In order to create a new library As an API client I want to make a request with the name of the desired library Scenario: Create a new library Given there is a running \"\" test network from scratch When I make a \"POST\" request to \"/api/invoke/createNewLibrary\" on port 880 with: \"\"\" { \"name\": \"Elizabeth's Library\" } \"\"\" Then the response code should be 200 And the response should have: \"\"\" { \"@key\": \"library:9cf6726a-a327-568a-baf1-5881393073bf\", \"@lastTouchBy\": \"orgMSP\", \"@lastTx\": \"createNewLibrary\", \"@assetType\": \"library\", \"name\": \"Elizabeth's Library\" } \"\"\" Scenario: Try to create a new library with a name that already exists Given there is a running \"\" test network Given there is a library with name \"John's Library\" When I make a \"POST\" request to \"/api/invoke/createNewLibrary\" on port 880 with: \"\"\" { \"name\": \"John's Library\" } \"\"\" Then the response code should be 409 This feature tests the ability to create a new library using the createNewLibrary tx through the API. It consists of two scenarios: one is a successful case, and the other tests when attempting to create a library with a name that already exists. Scenario 1: This scenario represents the successful creation of a new library. It verifies that the API can correctly handle the request with a new library name and returns the expected response. Scenario 2: This scenario tests the case when attempting to create a library with a name that already exists in the system. It checks whether the API responds with the appropriate status code (409) to indicate a conflict. The definition of Get Books By Author feature is as follows: Feature: Get Books By Author In order to get all the books by an author As an API client I want to make a request to the getBooksByAuthor transaction And receive the appropriate books Scenario: Request an author with multiple books Given there is a running \"\" test network And there are 3 books with prefix \"book\" by author \"Jack\" When I make a \"GET\" request to \"/api/query/getBooksByAuthor\" on port 880 with: \"\"\" { \"authorName\": \"Jack\" } \"\"\" Then the response code should be 200 And the \"result\" field should have size 3 Scenario: Request an author with no books Given there is a running \"\" test network When I make a \"GET\" request to \"/api/query/getBooksByAuthor\" on port 880 with: \"\"\" { \"authorName\": \"Mary\" } \"\"\" Then the response code should be 200 And the \"result\" field should have size 0 Scenario: Request an author with 2 books while there are other authors with more books Given there is a running \"\" test network Given there are 1 books with prefix \"fantasy\" by author \"Missy\" Given there are 2 books with prefix \"cook\" by author \"John\" When I make a \"GET\" request to \"/api/query/getBooksByAuthor\" on port 880 with: \"\"\" { \"authorName\": \"John\" } \"\"\" Then the response code should be 200 And the \"result\" field should have size 2 This feature tests the ability to retrieve books written by a specific author using the getBooksByAuthor transaction through the API. It consists of three scenarios that cover different cases based on the number of books by the requested author. Scenario 1: This scenario verifies that the API can successfully handle a request for an author who has multiple books in the system. It checks whether the API returns the correct response code (200) and that the \"result\" field in the response contains all the books by the author with a size of 3. Scenario 2: This scenario tests the case when requesting an author who has no books in the system. It checks whether the API returns the appropriate response code (200) and that the \"result\" field in the response is empty with a size of 0. Scenario 3: This scenario validates the API's response when requesting an author with two books, while other authors have more books in the system. It verifies whether the API returns the correct response code (200) and that the \"result\" field contains the two books by the requested author with a size of 2. The definition of Get Number Of Books From Library feature is as follows: Feature: Get Number Of Books From Library In order to create the number of books from library As an API client I want to make a request Scenario: Query Get Number Of Books From Library that Exists Given there is a running \"\" test network And I make a \"POST\" request to \"/api/invoke/createAsset\" on port 880 with: \"\"\" { \"asset\": [ { \"@assetType\": \"book\", \"title\": \"Meu Nome \u00e9 Maria\", \"author\": \"Maria Viana\" } ] } \"\"\" And I make a \"POST\" request to \"/api/invoke/createAsset\" on port 880 with: \"\"\" { \"asset\": [{ \"@assetType\": \"library\", \"name\": \"Maria's Library\", \"books\": [ { \"@assetType\": \"book\", \"@key\": \"book:a36a2920-c405-51c3-b584-dcd758338cb5\" } ] }] } \"\"\" When I make a \"GET\" request to \"/api/query/getNumberOfBooksFromLibrary\" on port 880 with: \"\"\" { \"library\": { \"@key\": \"library:3cab201f-9e2b-579d-b7b2-72297ed17f49\", \"@assetType\": \"library\" } } \"\"\" Then the response code should be 200 And the response should have: \"\"\" { \"numberOfBooks\": 1.0 } \"\"\" Scenario: Query Get Number Of Books From Library that Does Not Exists Given there is a running \"\" test network When I make a \"GET\" request to \"/api/query/getNumberOfBooksFromLibrary\" on port 880 with: \"\"\" { \"library\": { \"@key\": \"library:5c5b201f-9e4c-579d-b7b2-72297ed17f78\", \"@assetType\": \"library\" } } \"\"\" Then the response code should be 400 This feature tests the ability to retrieve the number of books from a library through the API. It consists of two scenarios: one scenario deals with querying a library that exists and has books, while the other scenario tests querying a library that does not exist. Scenario 1: This scenario verifies that the API can successfully retrieve the number of books from a library that exists in the system. It first creates a new book and a library with the book associated. Then it queries the number of books from the library and checks whether the API returns the correct response code (200) and whether the response contains the expected number of books (1). Scenario 2: This scenario tests the case when attempting to query the number of books from a library that does not exist in the system. It checks whether the API returns the appropriate response code (400) to indicate a bad request due to the non-existent library. The definition of Update Book Tentant feature is as follows: Feature: Update Book Tentant In order to update book tentant As an API client I want to make a request Scenario: Update Book With A Existing Tentant # The first 3 statements will be used by all scenarios on this feature Given there is a running \"\" test network And I make a \"POST\" request to \"/api/invoke/createAsset\" on port 880 with: \"\"\" { \"asset\": [{ \"@assetType\": \"book\", \"title\": \"Meu Nome \u00e9 Maria\", \"author\": \"Maria Viana\" }] } \"\"\" And I make a \"POST\" request to \"/api/invoke/createAsset\" on port 880 with: \"\"\" { \"asset\": [{ \"@assetType\": \"person\", \"name\": \"Maria\", \"id\": \"31820792048\" }] } \"\"\" When I make a \"PUT\" request to \"/api/invoke/updateBookTenant\" on port 880 with: \"\"\" { \"book\": { \"@assetType\": \"book\", \"@key\": \"book:a36a2920-c405-51c3-b584-dcd758338cb5\" }, \"tenant\": { \"@assetType\": \"person\", \"@key\": \"person:47061146-c642-51a1-844a-bf0b17cb5e19\" } } \"\"\" Then the response code should be 200 And the response should have: \"\"\" { \"@key\": \"book:a36a2920-c405-51c3-b584-dcd758338cb5\", \"@lastTouchBy\": \"orgMSP\", \"@lastTx\": \"updateBookTenant\", \"currentTenant\": { \"@assetType\": \"person\", \"@key\": \"person:47061146-c642-51a1-844a-bf0b17cb5e19\" } } \"\"\" Scenario: Update Book With A Not Existing Tentant Given there is a running \"\" test network When I make a \"PUT\" request to \"/api/invoke/updateBookTenant\" on port 880 with: \"\"\" { \"book\": { \"@assetType\": \"book\", \"@key\": \"book:a36a2920-c405-51c3-b584-dcd758338cb5\" }, \"tenant\": { \"@assetType\": \"person\", \"@key\": \"person:56891146-c6866-51a1-844a-bf0b17cb5e19\" } } \"\"\" Then the response code should be 404 This feature tests the ability to update the tenant of a book using the API. It consists of two scenarios: one scenario deals with updating a book with an existing tenant, and the other scenario tests updating a book with a non-existent tenant. Scenario 1: This scenario verifies that the API can successfully update the tenant of a book with an existing tenant. It creates a new book and a new person (tenant), associates the person with the book, and then makes a PUT request to update the book's tenant. The scenario checks whether the API returns the correct response code (200) and whether the book's tenant is correctly updated in the response. Scenario 2: This scenario tests the case when attempting to update the tenant of a book with a tenant that does not exist in the system. It makes a PUT request to update the book's tenant with the non-existing tenant. The scenario checks whether the API returns the appropriate response code (404) to indicate that the tenant does not exist in the system.","title":"Feature examples"},{"location":"testing/#implementation-of-steps","text":"Each step is implemented in chaincode/tests/request_test.go file. For Given there is a running \"\" test network from scratch there is the following implementation: func thereIsARunningTestNetworkFromScratch(arg1 string) error { // Start test network with 1 org only cmd := exec.Command(\"../../startDev.sh\", \"-n\", \"1\") _, err := cmd.Output() if err != nil { fmt.Println(err.Error()) return err } // Wait for ccapi err = waitForNetwork(\"880\") if err != nil { fmt.Println(err.Error()) return err } return nil } This function starts a test network from scratch with a single organization. It executes a shell command ../../startDev.sh -n 1 to start the test network. After starting the network, it waits for the ccapi to be available on port 880 using the waitForNetwork function. For When I make a \"[method]\" request to \"[endpoint]\" on port [port] with \"[body]\" there is the following implementation: func iMakeARequestToOnPortWith(ctx context.Context, method, endpoint string, port int, reqBody *godog.DocString) (context.Context, error) { var res *http.Response var req *http.Request var err error // Initialize http client client := &http.Client{} // Create request if method == \"GET\" { b64str := b64.StdEncoding.EncodeToString([]byte(reqBody.Content)) reqParam := \"?@request=\" + b64str req, err = http.NewRequest(\"GET\", \"http://localhost:\"+strconv.Itoa(port)+endpoint+reqParam, nil) if err != nil { return ctx, err } } else { dataAsBytes := bytes.NewBuffer([]byte(reqBody.Content)) req, err = http.NewRequest(method, \"http://localhost:\"+strconv.Itoa(port)+endpoint, dataAsBytes) if err != nil { return ctx, err } } // Set header and make request req.Header.Set(\"Content-Type\", \"application/json\") res, err = client.Do(req) if err != nil { return ctx, err } // Get status code and response body statusCode := res.StatusCode resBody, err := ioutil.ReadAll(res.Body) if err != nil { return ctx, err } res.Body.Close() // Append status code and response body to context bodyCtx := context.WithValue(ctx, bodyCtxKey{}, resBody) statusCtx := context.WithValue(bodyCtx, statusCtxKey{}, statusCode) return statusCtx, nil } This function makes an HTTP request to a specified endpoint on a given port. The function supports both GET and POST methods. If the method is GET , the request body is base64 encoded and added as a query parameter. If the method is POST , the request body is included in the request as JSON data. For Then the response code should be [code] there is the following implementation: func theResponseCodeShouldBe(ctx context.Context, expectedCode int) (context.Context, error) { // Get Status Code from context statusCode, ok := ctx.Value(statusCtxKey{}).(int) if !ok { return ctx, errors.New(\"context unaveilable while retrieving status\") } if statusCode != expectedCode { // Get Response body from context resBody, ok := ctx.Value(bodyCtxKey{}).([]byte) if !ok { return ctx, errors.New(\"unaveilable context while retrieving body\") } // Test Failed return ctx, fmt.Errorf(\"received wrong status response. Got %d Expected: %d\\nResponse body: %s\", statusCode, expectedCode, string(resBody)) } return ctx, nil } This function checks whether the received HTTP response status code matches the expected code. For And the response should have there is the following implementation: func theResponseShouldHave(ctx context.Context, body *godog.DocString) error { // Get 'ResponseBody' from context respBody, ok := ctx.Value(bodyCtxKey{}).([]byte) if !ok { return errors.New(\"unavailable context\") } var expected map[string]interface{} var received map[string]interface{} if err := json.Unmarshal([]byte(body.Content), &expected); err != nil { return err } if err := json.Unmarshal(respBody, &received); err != nil { return err } for key, value := range expected { if !reflect.DeepEqual(value, received[key]) { var expectedBytes []byte var receivedBytes []byte var err error if expectedBytes, err = json.MarshalIndent(value, \"\", \" \"); err != nil { return err } if receivedBytes, err = json.MarshalIndent(received[key], \"\", \" \"); err != nil { return err } return fmt.Errorf(\"Expected %s to be equal %s, but received %s\", key, expectedBytes, receivedBytes) } } return nil } This function checks if the received HTTP response body matches the expected response body defined in the Godog scenario step. It first retrieves the actual response body and the expected response body from the context. It unmarshals both JSON strings into corresponding map-like structures to facilitate comparison. The function performs a deep comparison between the value of each key in the expected and received response bodies using reflect.DeepEqual function. For And the \"[field]\" field should have size [size] there is the following implementation: func theFieldShouldHaveSize(ctx context.Context, field string, expectedSize int) (context.Context, error) { // Get 'ResponseBody' from context respBody, ok := ctx.Value(bodyCtxKey{}).([]byte) if !ok { return ctx, errors.New(\"unavailable context\") } var bodyMap map[string]interface{} if err := json.Unmarshal(respBody, &bodyMap); err != nil { return ctx, err } resultField, ok := bodyMap[field] if !ok { return ctx, errors.New(\"unavailable filed on body response\") } fieldLen := len(resultField.([]interface{})) if fieldLen != expectedSize { // Test Failed return ctx, fmt.Errorf(\"received wrong filed size on response body. Got %d Expected: %d\\nResponse body: %s\", fieldLen, expectedSize, string(respBody)) } return ctx, nil } This function is used to check if a specific field in the received JSON response body has the expected size (number of elements). It is typically used in Godog scenarios to verify the size of an array or a list-like field in the response. For And there are [number] books with prefix \"[prefix]\" by author \"[name]\" there is the following implementation: func thereAreBooksWithPrefixByAuthor(ctx context.Context, nBooks int, prefix string, author string) (context.Context, error) { var res *http.Response var err error for i := 1; i <= nBooks; i++ { // Verify if book already exists requestJSON := map[string]interface{}{ \"query\": map[string]interface{}{ \"selector\": map[string]interface{}{ \"author\": author, \"title\": prefix + strconv.Itoa(i), \"@assetType\": \"book\", }, }, \"resolve\": true, } jsonStr, e := json.Marshal(requestJSON) if e != nil { return ctx, err } dataAsBytes := bytes.NewBuffer([]byte(jsonStr)) if res, err = http.Post(\"http://localhost/api/query/search\", \"application/json\", dataAsBytes); err != nil { return ctx, err } resBody, err := ioutil.ReadAll(res.Body) if err != nil { return ctx, err } res.Body.Close() var received map[string]interface{} if err = json.Unmarshal(resBody, &received); err != nil { return ctx, err } // Create book if it doesnt exists if len(received[\"result\"].([]interface{})) == 0 { requestJSON := map[string]interface{}{ \"asset\": []interface{}{ map[string]interface{}{ \"author\": author, \"title\": prefix + strconv.Itoa(i), \"@assetType\": \"book\", }, }, } jsonStr, e := json.Marshal(requestJSON) if e != nil { return ctx, err } dataAsBytes := bytes.NewBuffer([]byte(jsonStr)) if res, err = http.Post(\"http://localhost:880/api/invoke/createAsset\", \"application/json\", dataAsBytes); err != nil { return ctx, err } if res.StatusCode != 200 { return ctx, errors.New(\"Failed to create book asset\") } } } return ctx, nil } This function is used to ensure that there are a specific number of books with a given prefix and author in the system. It is typically used in Godog scenarios to set up the required test data before running tests that involve books and authors. For Given there is a library with name \"[name]\" there is the following implementation: func thereIsALibraryWithName(ctx context.Context, name string) (context.Context, error) { var res *http.Response var err error // Verify if library already exists requestJSON := map[string]interface{}{ \"query\": map[string]interface{}{ \"selector\": map[string]interface{}{ \"name\": name, \"@assetType\": \"library\", }, }, \"resolve\": true, } jsonStr, e := json.Marshal(requestJSON) if e != nil { return ctx, err } dataAsBytes := bytes.NewBuffer([]byte(jsonStr)) if res, err = http.Post(\"http://localhost/api/query/search\", \"application/json\", dataAsBytes); err != nil { return ctx, err } resBody, err := ioutil.ReadAll(res.Body) if err != nil { return ctx, err } res.Body.Close() var received map[string]interface{} if err = json.Unmarshal(resBody, &received); err != nil { return ctx, err } // Create library if it doesnt exists if len(received[\"result\"].([]interface{})) == 0 { requestJSON = map[string]interface{}{ \"asset\": []interface{}{ map[string]interface{}{ \"name\": name, \"@assetType\": \"library\", }, }, } jsonStr, e = json.Marshal(requestJSON) if e != nil { return ctx, err } dataAsBytes = bytes.NewBuffer([]byte(jsonStr)) if res, err = http.Post(\"http://localhost:880/api/invoke/createAsset\", \"application/json\", dataAsBytes); err != nil { return ctx, err } if res.StatusCode != 200 { return ctx, errors.New(\"Failed to create library asset\") } } return ctx, nil } This function is used to ensure that a library with a specific name exists in the system. It is typically used in Godog scenarios to set up the required test data before running tests that involve libraries. If the library does not exist, it creates a new library asset. It's required to initialize the scenario with the implementation of each step. The function below describes how to do it: func InitializeScenario(ctx *godog.ScenarioContext) { ctx.Step(`^I make a \"([^\"]*)\" request to \"([^\"]*)\" on port (\\d+) with:$`, iMakeARequestToOnPortWith) ctx.Step(`^the response code should be (\\d+)$`, theResponseCodeShouldBe) ctx.Step(`^the response should have:$`, theResponseShouldHave) ctx.Step(`^there is a running \"([^\"]*)\" test network$`, thereIsARunningTestNetwork) ctx.Step(`^there is a running \"([^\"]*)\" test network from scratch$`, thereIsARunningTestNetworkFromScratch) ctx.Step(`^there are (\\d+) books with prefix \"([^\"]*)\" by author \"([^\"]*)\"$`, thereAreBooksWithPrefixByAuthor) ctx.Step(`^the \"([^\"]*)\" field should have size (\\d+)$`, theFieldShouldHaveSize) ctx.Step(`^there is a library with name \"([^\"]*)\"$`, thereIsALibraryWithName) }","title":"Implementation of steps"},{"location":"testing/#run-godog-tests","text":"Begin by installing godog using the following command: $ go install github.com/cucumber/godog/cmd/godog@latest Once godog is successfully installed, utilize the provided script to run tests effortlessly: $ ./godog.sh","title":"Run Godog tests"},{"location":"testing/#using-golang-testing","text":"It's also possible to test the developed transactions using Golang testing library. In this type of testing you can simulate a transaction call and compare its results to an expected value. It's important to note that this type of testing does not work on transactions that reads the chaincode state database (such as using couchdb queries) nor transactions that reads an asset history. For the cc-tools-demo repository, there are tests for the createNewLibrary , getNumberOfBooksFromLibrary and updateBookTenant transactions. The tests are defined in the chaincode/ folder. chaincode/ main_test.go // setup the test enviroment txdefs_createNewLibrary_test.go // tests the createNewLibrary transaction txdefs_getNumberOfBooksFromLibrary_test.go // tests the getNumberOfBooksFromLibrary transaction txdefs_updateBookTenant_test.go // tests the updateBookTenant transaction","title":"Using Golang testing"},{"location":"testing/#test-examples","text":"The definition of Create New Library test is as follows: func TestCreateNewLibrary(t *testing.T) { stub := mock.NewMockStub(\"org3MSP\", new(cc.CCDemo)) expectedResponse := map[string]interface{}{ \"@key\": \"library:3cab201f-9e2b-579d-b7b2-72297ed17f49\", \"@lastTouchBy\": \"org3MSP\", \"@lastTx\": \"createNewLibrary\", \"@assetType\": \"library\", \"name\": \"Maria's Library\", } req := map[string]interface{}{ \"name\": \"Maria's Library\", } reqBytes, err := json.Marshal(req) if err != nil { t.FailNow() } res := stub.MockInvoke(\"createNewLibrary\", [][]byte{ []byte(\"createNewLibrary\"), reqBytes, }) expectedResponse[\"@lastUpdated\"] = stub.TxTimestamp.AsTime().Format(time.RFC3339) if res.GetStatus() != 200 { log.Println(res) t.FailNow() } var resPayload map[string]interface{} err = json.Unmarshal(res.GetPayload(), &resPayload) if err != nil { log.Println(err) t.FailNow() } if !reflect.DeepEqual(resPayload, expectedResponse) { log.Println(\"these should be equal\") log.Printf(\"%#v\\n\", resPayload) log.Printf(\"%#v\\n\", expectedResponse) t.FailNow() } var state map[string]interface{} stateBytes := stub.State[\"library:3cab201f-9e2b-579d-b7b2-72297ed17f49\"] err = json.Unmarshal(stateBytes, &state) if err != nil { log.Println(err) t.FailNow() } if !reflect.DeepEqual(state, expectedResponse) { log.Println(\"these should be equal\") log.Printf(\"%#v\\n\", state) log.Printf(\"%#v\\n\", expectedResponse) t.FailNow() } } The following steps occur on this test: - A mock stub for org3 is created - The objects with the expected response for the createNewLibrary transaction and the transaction request are created - The createNewLibrary transaction is invoked using the request defined on the previous step - The timestamp from the stub is added to the expectedResponse object - The status of the invoke is checked for the 200 code - A deep compare is made between the expected response object and the invoke response - The state for the key of the created object in the stub is also compared to the expected response The definition of Get Number Of Books From Library test is as follows: func TestGetNumberOfBooksFromLibrary(t *testing.T) { stub := mock.NewMockStub(\"org2MSP\", new(CCDemo)) // Setup state setupBook := map[string]interface{}{ \"@key\": \"book:a36a2920-c405-51c3-b584-dcd758338cb5\", \"@lastTouchBy\": \"org2MSP\", \"@lastTx\": \"createAsset\", \"@assetType\": \"book\", \"title\": \"Meu Nome \u00e9 Maria\", \"author\": \"Maria Viana\", \"genres\": []interface{}{\"biography\", \"non-fiction\"}, \"published\": \"2019-05-06T22:12:41Z\", } setupLibrary := map[string]interface{}{ \"@key\": \"library:3cab201f-9e2b-579d-b7b2-72297ed17f49\", \"@lastTouchBy\": \"org3MSP\", \"@lastTx\": \"createNewLibrary\", \"@assetType\": \"library\", \"name\": \"Maria's Library\", \"books\": []map[string]interface{}{ { \"@assetType\": \"book\", \"@key\": \"book:a36a2920-c405-51c3-b584-dcd758338cb5\", }, }, } setupBookJSON, _ := json.Marshal(setupBook) setupLibraryJSON, _ := json.Marshal(setupLibrary) stub.MockTransactionStart(\"setupGetNumberOfBooksFromLibrary\") stub.PutState(\"book:a36a2920-c405-51c3-b584-dcd758338cb5\", setupBookJSON) stub.PutState(\"library:3cab201f-9e2b-579d-b7b2-72297ed17f49\", setupLibraryJSON) refIdx, err := stub.CreateCompositeKey(\"book:a36a2920-c405-51c3-b584-dcd758338cb5\", []string{\"library:3cab201f-9e2b-579d-b7b2-72297ed17f49\"}) if err != nil { log.Println(err) t.FailNow() } stub.PutState(refIdx, []byte{0x00}) stub.MockTransactionEnd(\"setupGetNumberOfBooksFromLibrary\") expectedResponse := map[string]interface{}{ \"numberOfBooks\": 1.0, } req := map[string]interface{}{ \"library\": map[string]interface{}{ \"name\": \"Maria's Library\", }, } reqBytes, err := json.Marshal(req) if err != nil { t.FailNow() } res := stub.MockInvoke(\"getNumberOfBooksFromLibrary\", [][]byte{ []byte(\"getNumberOfBooksFromLibrary\"), reqBytes, }) if res.GetStatus() != 200 { log.Println(res) t.FailNow() } var resPayload map[string]interface{} err = json.Unmarshal(res.GetPayload(), &resPayload) if err != nil { log.Println(err) t.FailNow() } if !reflect.DeepEqual(resPayload, expectedResponse) { log.Println(\"these should be equal\") log.Printf(\"%#v\\n\", resPayload) log.Printf(\"%#v\\n\", expectedResponse) t.FailNow() } } The following steps occur on this test: - A mock stub for org2 is created - The state objects for the book and the library are defined and added to the mock state on the stub - The objects with the expected response for the getNumberOfBooksFromLibrary transaction and the transaction request are created - The getNumberOfBooksFromLibrary transaction is invoked using the request defined on the previous step - The status of the invoke is checked for the 200 code - A deep compare is made between the expected response object and the invoke response The definition of Update Book Tenant test is as follows: func TestUpdateBookTenant(t *testing.T) { stub := mock.NewMockStub(\"org1MSP\", new(CCDemo)) // State setup setupPerson := map[string]interface{}{ \"@key\": \"person:47061146-c642-51a1-844a-bf0b17cb5e19\", \"@lastTouchBy\": \"org1MSP\", \"@lastTx\": \"createAsset\", \"@assetType\": \"person\", \"name\": \"Maria\", \"id\": \"31820792048\", \"height\": 0.0, } setupBook := map[string]interface{}{ \"@key\": \"book:a36a2920-c405-51c3-b584-dcd758338cb5\", \"@lastTouchBy\": \"org2MSP\", \"@lastTx\": \"createAsset\", \"@assetType\": \"book\", \"title\": \"Meu Nome \u00e9 Maria\", \"author\": \"Maria Viana\", // \"currentTenant\": map[string]interface{}{ // \"@assetType\": \"person\", // \"@key\": \"person:47061146-c642-51a1-844a-bf0b17cb5e19\", // }, \"genres\": []interface{}{\"biography\", \"non-fiction\"}, \"published\": \"2019-05-06T22:12:41Z\", } setupPersonJSON, _ := json.Marshal(setupPerson) setupBookJSON, _ := json.Marshal(setupBook) stub.MockTransactionStart(\"setupUpdateBookTenant\") stub.PutState(\"person:47061146-c642-51a1-844a-bf0b17cb5e19\", setupPersonJSON) stub.PutState(\"book:a36a2920-c405-51c3-b584-dcd758338cb5\", setupBookJSON) stub.MockTransactionEnd(\"setupUpdateBookTenant\") req := map[string]interface{}{ \"book\": map[string]interface{}{ \"@key\": \"book:a36a2920-c405-51c3-b584-dcd758338cb5\", }, \"tenant\": map[string]interface{}{ \"@key\": \"person:47061146-c642-51a1-844a-bf0b17cb5e19\", }, } reqBytes, _ := json.Marshal(req) res := stub.MockInvoke(\"updateBookTenant\", [][]byte{ []byte(\"updateBookTenant\"), reqBytes, }) if res.GetStatus() != 200 { log.Println(res) t.FailNow() } var resPayload map[string]interface{} err := json.Unmarshal(res.GetPayload(), &resPayload) if err != nil { log.Println(err) t.FailNow() } expectedResponse := map[string]interface{}{ \"@key\": \"book:a36a2920-c405-51c3-b584-dcd758338cb5\", \"@lastTouchBy\": \"org1MSP\", \"@lastTx\": \"updateBookTenant\", \"@assetType\": \"book\", \"title\": \"Meu Nome \u00e9 Maria\", \"author\": \"Maria Viana\", \"currentTenant\": map[string]interface{}{ \"@assetType\": \"person\", \"@key\": \"person:47061146-c642-51a1-844a-bf0b17cb5e19\", }, \"genres\": []interface{}{\"biography\", \"non-fiction\"}, \"published\": \"2019-05-06T22:12:41Z\", } expectedResponse[\"@lastUpdated\"] = stub.TxTimestamp.AsTime().Format(time.RFC3339) if !reflect.DeepEqual(resPayload, expectedResponse) { log.Println(\"these should be equal\") log.Printf(\"%#v\\n\", resPayload) log.Printf(\"%#v\\n\", expectedResponse) t.FailNow() } var state map[string]interface{} stateBytes := stub.State[\"book:a36a2920-c405-51c3-b584-dcd758338cb5\"] err = json.Unmarshal(stateBytes, &state) if err != nil { log.Println(err) t.FailNow() } if !reflect.DeepEqual(state, expectedResponse) { log.Println(\"these should be equal\") log.Printf(\"%#v\\n\", state) log.Printf(\"%#v\\n\", expectedResponse) t.FailNow() } } The following steps occur on this test: - A mock stub for org1 is created - The state objects for the book and the person are defined and added to the mock state on the stub - The object with the request for the updateBookTenant transaction is created - The status of the invoke is checked for the 200 code - The expected response object is created, with the stub timestamp added to the @lastUpdated value - A deep compare is made between the expected response object and the invoke response - The state for the key of the book in the stub is also compared to the expected response","title":"Test examples"},{"location":"testing/#running-the-tests","text":"To run the tests, execute the following command: cd chaincode && \\ go test && \\ cd .. If the tests were succeseful, the following messages should appear on the terminal: main.go:131: 200 init 40.796\u00b5s main.go:131: 200 getNumberOfBooksFromLibrary 31.298\u00b5s main.go:131: 200 updateBookTenant 136.09\u00b5s main.go:131: 200 createNewLibrary 60.794\u00b5s PASS ok github.com/goledgerdev/cc-tools-demo/chaincode 0.006s","title":"Running the tests"},{"location":"transactions/","text":"Transactions GoLedger CC-Tools transactions represent the GoLang methods that can modify the assets within the Blockchain ledger ( Hyperledger Fabric Channel ) Hyperledger Fabric assets can only be created or modified by executing chaincode transactions inside endorsing peers. Goledger CC-Tools library has a range of pre-defined transactions: CreateAsset - creation of a new asset UpdateAsset - update an existing asset DeleteAsset - removing an asset from the current ledger state ReadAsset - read the asset in its last ledger status ReadAssetHistory - history of an asset's ledger status Search - asset listing GoLedger CC-Tools library enables the creation of custom transactions. cc-tools-demo repository provides 3 example transactions: CreateNewLibrary - create a new asset of type Library GetBooksByAuthor - returns assets Book given an Author name GetNumberOfBooksFromLibrary - returns the number of assets Book inside asset Library UpdateBookTenant - update field currentTenant inside asset Book The definition of assets is done in the chaincode/txdefs folder for GoLedger CC-Tools library. The of files from the txdefs folder is shown below: chaincode/ txdefs/ # transations folder createNewLibrary.go # library creation getBooksByAuthor.go # returns books by an author getNumberOfBooksFromLibrary.go # returns the number of books at the library asset updateBookTenant.go # changes de tenant of book txList.go # list of custom transactions Transaction definition A custom transaction construction is done by creating a file inside the chaincode/txdefs folder An asset has the following fields: Tag : string field to define the transaction name internally referenced by the code and by the Rest Api endpoints. It cannot have spaces or special characters. If it has the same name as a predefined transaction ( createAsset , updateAsset , deleteAsset , readAsset , readAssetHistory or search ), this transaction will be replaced by the one in the txdefs directory. Label : string field to define the label to be used by external applications. Free text. Description : asset description string field to be used by external applications. Free text. Method : Rest API method type. It can be POST , GET , PUT or DELETE . Callers : used to define which organizations can call this transaction. Args : arguments. It has its own fields. Routine : transaction source code. ReadOnly : boolean field to indicate that the tx does not alter the world state. MetaTx : boolean field to indicate that the tx does not encode a business-specific rule, but an internal process of the chaincode e.g. listing available asset types. Transaction argument definition A transaction has a set of customizable input arguments. An argument has the following fields: Tag : string field to define the argument name internally referenced by the code and by the Rest Api endpoints. It cannot have spaces or special characters. Label : string field to define the label to be used by external applications. Free text. Description : asset description string field to be used by external applications. Free text. Required : identifies if the argument is required. Boolean field. DataType : property type. CC-Tools has the following default types: string, number, datetime, boolean and @object . Private : boolean field to indicate that argument will be used for private data. StubWrapper The main purpose of the StubWrapper is to provide additional functionalities and simplify the development of chaincodes. The StubWrapper maintains a WriteSet to ensure that modifications made during the execution of a chaincode are properly reflected when querying the ledger state. Even if these changes have not been confirmed on the ledger yet, the StubWrapper records the pending modifications in the WriteSet. This allows subsequent queries to utilize the WriteSet to return the updated data, ensuring consistency and accuracy of information during the execution of the chaincode. The same applies to private data. Transaction examples cc-tools-demo repository has the following custom transaction configuration: chaincode/ txdefs/ # transations folder createNewLibrary.go # library creation getBooksByAuthor.go # returns books by an author getNumberOfBooksFromLibrary.go # returns the number of books at the library asset updateBookTenant.go # changes de tenant of book txList.go # list of custom transactions In addition to the files for each transaction that can be used by the Goledger CC-Tools library they also must be registered inside txList.go file The definition of the CreateNewLibrary transaction is as follows: var CreateNewLibrary = tx.Transaction{ Tag: \"createNewLibrary\", Label: \"Create New Library\", Description: \"Create a New Library\", Method: \"POST\", Callers: []string{\"$org3MSP\"}, // Only org3 can call this transaction Args: []tx.Argument{ { Tag: \"name\", Label: \"Name\", Description: \"Name of the library\", DataType: \"string\", Required: true, }, }, Routine: func(stub *sw.StubWrapper, req map[string]interface{}) ([]byte, errors.ICCError) { name, _ := req[\"name\"].(string) libraryMap := make(map[string]interface{}) libraryMap[\"@assetType\"] = \"library\" libraryMap[\"name\"] = name libraryAsset, err := assets.NewAsset(libraryMap) if err != nil { return nil, errors.WrapError(err, \"Failed to create a new asset\") } // Save the new library on channel _, err = libraryAsset.PutNew(stub) if err != nil { return nil, errors.WrapError(err, \"Error saving asset on blockchain\") } // Marshal asset back to JSON format libraryJSON, nerr := json.Marshal(libraryAsset) if nerr != nil { return nil, errors.WrapError(nil, \"failed to encode asset to JSON format\") } // Marshall message to be logged logMsg, ok := json.Marshal(fmt.Sprintf(\"New library name: %s\", name)) if ok != nil { return nil, errors.WrapError(nil, \"failed to encode asset to JSON format\") } // Call event to log the message events.CallEvent(stub, \"createLibraryLog\", logMsg) return libraryJSON, nil }, } According to the description above, CreateNewLibrary transaction has the following characteristics: Only org3 can call this method POST method for Rest Api Argument name of type string is required. The transaction uses the NewAsset function to prepare a new asset (keys, etc) and the PutNew function to create the asset in the channel . A log event for the type createLibraryLog is called with the created library name The definition of the GetBooksByAuthor transaction is as follows: var GetBooksByAuthor = tx.Transaction{ Tag: \"getBooksByAuthor\", Label: \"Get Books by the Author Name\", Description: \"Return all the books from an author\", Method: \"GET\", Callers: []string{\"$org1MSP\", \"$org2MSP\", \"$orgMSP\"}, // Only org1 and org2 can call this transaction Args: []tx.Argument{ { Tag: \"authorName\", Label: \"Author Name\", Description: \"Author Name\", DataType: \"string\", Required: true, }, { Tag: \"limit\", Label: \"Limit\", Description: \"Limit\", DataType: \"number\", }, }, Routine: func(stub *sw.StubWrapper, req map[string]interface{}) ([]byte, errors.ICCError) { authorName, _ := req[\"authorName\"].(string) limit, hasLimit := req[\"limit\"].(float64) if hasLimit && limit <= 0 { return nil, errors.NewCCError(\"limit must be greater than 0\", 400) } // Prepare couchdb query query := map[string]interface{}{ \"selector\": map[string]interface{}{ \"@assetType\": \"book\", \"author\": authorName, }, } if hasLimit { query[\"limit\"] = limit } var err error response, err := assets.Search(stub, query, \"\", true) if err != nil { return nil, errors.WrapErrorWithStatus(err, \"error searching for book's author\", 500) } responseJSON, err := json.Marshal(response) if err != nil { return nil, errors.WrapErrorWithStatus(err, \"error marshaling response\", 500) } return responseJSON, nil }, } Only org1 and org2 can call this method. GET method for Rest Api. Argument authorName of type string is required. Argument limit of type number is optional. The transaction uses the Search function to query Book assets from the ledger, filtering by author . The definition of the UpdateBookTenant transaction is as follows: var UpdateBookTenant = tx.Transaction{ Tag: \"updateBookTenant\", Label: \"Update Book Tenant\", Description: \"Change the tenant of a book\", Method: \"PUT\", Callers: []string{`$org\\dMSP`}, // Any orgs can call this transaction Args: []tx.Argument{ { Tag: \"book\", Label: \"Book\", Description: \"Book\", DataType: \"->book\", Required: true, }, { Tag: \"tenant\", Label: \"tenant\", Description: \"New tenant of the book\", DataType: \"->person\", }, }, Routine: func(stub *sw.StubWrapper, req map[string]interface{}) ([]byte, errors.ICCError) { bookKey, ok := req[\"book\"].(assets.Key) if !ok { return nil, errors.WrapError(nil, \"Parameter book must be an asset\") } tenantKey, ok := req[\"tenant\"].(assets.Key) if !ok { return nil, errors.WrapError(nil, \"Parameter tenant must be an asset\") } // Returns Book from channel bookAsset, err := bookKey.Get(stub) if err != nil { return nil, errors.WrapError(err, \"failed to get asset from the ledger\") } bookMap := (map[string]interface{})(*bookAsset) // Returns person from channel tenantAsset, err := tenantKey.Get(stub) if err != nil { return nil, errors.WrapError(err, \"failed to get asset from the ledger\") } tenantMap := (map[string]interface{})(*tenantAsset) updatedTenantKey := make(map[string]interface{}) updatedTenantKey[\"@assetType\"] = \"person\" updatedTenantKey[\"@key\"] = tenantMap[\"@key\"] // Update data bookMap[\"currentTenant\"] = updatedTenantKey bookMap, err = bookAsset.Update(stub, bookMap) if err != nil { return nil, errors.WrapError(err, \"failed to update asset\") } // Marshal asset back to JSON format bookJSON, nerr := json.Marshal(bookMap) if nerr != nil { return nil, errors.WrapError(err, \"failed to marshal response\") } return bookJSON, nil }, } Any organization that starts with \"org\" followed by a number (org1, org2, org3, org4, etc) can call this method. PUT method for Rest Api Argument book of type Book is mandatory. Argument person of type Person required. The transaction uses the Get function to read the the assets Book and Person information from the ledger The transaction uses the Update function to updates the asset information Book inside the ledger The definition of the GetNumberOfBooksFromLibrary transaction is as follows: var GetNumberOfBooksFromLibrary = tx.Transaction{ Tag: \"getNumberOfBooksFromLibrary\", Label: \"Get Number Of Books From Library\", Description: \"Return the number of books of a library\", Method: \"GET\", Callers: []string{\"$org2MSP\", \"$orgMSP\"}, // Only org2 can call this transactions Args: []tx.Argument{ { Tag: \"library\", Label: \"Library\", Description: \"Library\", DataType: \"->library\", Required: true, }, }, Routine: func(stub *sw.StubWrapper, req map[string]interface{}) ([]byte, errors.ICCError) { libraryKey, _ := req[\"library\"].(assets.Key) // Returns Library from channel libraryMap, err := libraryKey.GetMap(stub) if err != nil { return nil, errors.WrapError(err, \"failed to get asset from the ledger\") } numberOfBooks := 0 books, ok := libraryMap[\"books\"].([]interface{}) if ok { numberOfBooks = len(books) } returnMap := make(map[string]interface{}) returnMap[\"numberOfBooks\"] = numberOfBooks // Marshal asset back to JSON format returnJSON, nerr := json.Marshal(returnMap) if nerr != nil { return nil, errors.WrapError(err, \"failed to marshal response\") } return returnJSON, nil }, } Only org2 can call this method. GET method for Rest Api Argument library of type Library is required. The transaction uses the Get function to read Library asset information from the ledger Transaction list definition The registration of the transactions that will be used by GoLedger CC-Tools library must be also done inside chaincode/txList.go file var txList = []tx.Transaction{ tx.CreateAsset, tx.UpdateAsset, tx.DeleteAsset, txdefs.CreateNewLibrary, txdefs.GetNumberOfBooksFromLibrary, txdefs.UpdateBookTenant, txdefs.GetBooksByAuthor, } META-INF Indexes allow a database to be queried without having to examine every row with every query, making them run faster and more efficiently. It's mandatory to create indexes for fields that will be used for sorted queries. The JSON index files must be located under the path META-INF/statedb/couchdb/indexes which is located inside the directory where the chaincode resides. For example: { \"index\":{ \"fields\":[ {\"published\": \"asc\"} ] }, \"ddoc\":\"indexListarBooksAscDoc\", \"name\":\"indexListarBooksAsc\", \"type\":\"json\" } See more on Create an index .","title":"Transactions"},{"location":"transactions/#transactions","text":"GoLedger CC-Tools transactions represent the GoLang methods that can modify the assets within the Blockchain ledger ( Hyperledger Fabric Channel ) Hyperledger Fabric assets can only be created or modified by executing chaincode transactions inside endorsing peers. Goledger CC-Tools library has a range of pre-defined transactions: CreateAsset - creation of a new asset UpdateAsset - update an existing asset DeleteAsset - removing an asset from the current ledger state ReadAsset - read the asset in its last ledger status ReadAssetHistory - history of an asset's ledger status Search - asset listing GoLedger CC-Tools library enables the creation of custom transactions. cc-tools-demo repository provides 3 example transactions: CreateNewLibrary - create a new asset of type Library GetBooksByAuthor - returns assets Book given an Author name GetNumberOfBooksFromLibrary - returns the number of assets Book inside asset Library UpdateBookTenant - update field currentTenant inside asset Book The definition of assets is done in the chaincode/txdefs folder for GoLedger CC-Tools library. The of files from the txdefs folder is shown below: chaincode/ txdefs/ # transations folder createNewLibrary.go # library creation getBooksByAuthor.go # returns books by an author getNumberOfBooksFromLibrary.go # returns the number of books at the library asset updateBookTenant.go # changes de tenant of book txList.go # list of custom transactions","title":"Transactions"},{"location":"transactions/#transaction-definition","text":"A custom transaction construction is done by creating a file inside the chaincode/txdefs folder An asset has the following fields: Tag : string field to define the transaction name internally referenced by the code and by the Rest Api endpoints. It cannot have spaces or special characters. If it has the same name as a predefined transaction ( createAsset , updateAsset , deleteAsset , readAsset , readAssetHistory or search ), this transaction will be replaced by the one in the txdefs directory. Label : string field to define the label to be used by external applications. Free text. Description : asset description string field to be used by external applications. Free text. Method : Rest API method type. It can be POST , GET , PUT or DELETE . Callers : used to define which organizations can call this transaction. Args : arguments. It has its own fields. Routine : transaction source code. ReadOnly : boolean field to indicate that the tx does not alter the world state. MetaTx : boolean field to indicate that the tx does not encode a business-specific rule, but an internal process of the chaincode e.g. listing available asset types.","title":"Transaction definition"},{"location":"transactions/#transaction-argument-definition","text":"A transaction has a set of customizable input arguments. An argument has the following fields: Tag : string field to define the argument name internally referenced by the code and by the Rest Api endpoints. It cannot have spaces or special characters. Label : string field to define the label to be used by external applications. Free text. Description : asset description string field to be used by external applications. Free text. Required : identifies if the argument is required. Boolean field. DataType : property type. CC-Tools has the following default types: string, number, datetime, boolean and @object . Private : boolean field to indicate that argument will be used for private data.","title":"Transaction argument definition"},{"location":"transactions/#stubwrapper","text":"The main purpose of the StubWrapper is to provide additional functionalities and simplify the development of chaincodes. The StubWrapper maintains a WriteSet to ensure that modifications made during the execution of a chaincode are properly reflected when querying the ledger state. Even if these changes have not been confirmed on the ledger yet, the StubWrapper records the pending modifications in the WriteSet. This allows subsequent queries to utilize the WriteSet to return the updated data, ensuring consistency and accuracy of information during the execution of the chaincode. The same applies to private data.","title":"StubWrapper"},{"location":"transactions/#transaction-examples","text":"cc-tools-demo repository has the following custom transaction configuration: chaincode/ txdefs/ # transations folder createNewLibrary.go # library creation getBooksByAuthor.go # returns books by an author getNumberOfBooksFromLibrary.go # returns the number of books at the library asset updateBookTenant.go # changes de tenant of book txList.go # list of custom transactions In addition to the files for each transaction that can be used by the Goledger CC-Tools library they also must be registered inside txList.go file The definition of the CreateNewLibrary transaction is as follows: var CreateNewLibrary = tx.Transaction{ Tag: \"createNewLibrary\", Label: \"Create New Library\", Description: \"Create a New Library\", Method: \"POST\", Callers: []string{\"$org3MSP\"}, // Only org3 can call this transaction Args: []tx.Argument{ { Tag: \"name\", Label: \"Name\", Description: \"Name of the library\", DataType: \"string\", Required: true, }, }, Routine: func(stub *sw.StubWrapper, req map[string]interface{}) ([]byte, errors.ICCError) { name, _ := req[\"name\"].(string) libraryMap := make(map[string]interface{}) libraryMap[\"@assetType\"] = \"library\" libraryMap[\"name\"] = name libraryAsset, err := assets.NewAsset(libraryMap) if err != nil { return nil, errors.WrapError(err, \"Failed to create a new asset\") } // Save the new library on channel _, err = libraryAsset.PutNew(stub) if err != nil { return nil, errors.WrapError(err, \"Error saving asset on blockchain\") } // Marshal asset back to JSON format libraryJSON, nerr := json.Marshal(libraryAsset) if nerr != nil { return nil, errors.WrapError(nil, \"failed to encode asset to JSON format\") } // Marshall message to be logged logMsg, ok := json.Marshal(fmt.Sprintf(\"New library name: %s\", name)) if ok != nil { return nil, errors.WrapError(nil, \"failed to encode asset to JSON format\") } // Call event to log the message events.CallEvent(stub, \"createLibraryLog\", logMsg) return libraryJSON, nil }, } According to the description above, CreateNewLibrary transaction has the following characteristics: Only org3 can call this method POST method for Rest Api Argument name of type string is required. The transaction uses the NewAsset function to prepare a new asset (keys, etc) and the PutNew function to create the asset in the channel . A log event for the type createLibraryLog is called with the created library name The definition of the GetBooksByAuthor transaction is as follows: var GetBooksByAuthor = tx.Transaction{ Tag: \"getBooksByAuthor\", Label: \"Get Books by the Author Name\", Description: \"Return all the books from an author\", Method: \"GET\", Callers: []string{\"$org1MSP\", \"$org2MSP\", \"$orgMSP\"}, // Only org1 and org2 can call this transaction Args: []tx.Argument{ { Tag: \"authorName\", Label: \"Author Name\", Description: \"Author Name\", DataType: \"string\", Required: true, }, { Tag: \"limit\", Label: \"Limit\", Description: \"Limit\", DataType: \"number\", }, }, Routine: func(stub *sw.StubWrapper, req map[string]interface{}) ([]byte, errors.ICCError) { authorName, _ := req[\"authorName\"].(string) limit, hasLimit := req[\"limit\"].(float64) if hasLimit && limit <= 0 { return nil, errors.NewCCError(\"limit must be greater than 0\", 400) } // Prepare couchdb query query := map[string]interface{}{ \"selector\": map[string]interface{}{ \"@assetType\": \"book\", \"author\": authorName, }, } if hasLimit { query[\"limit\"] = limit } var err error response, err := assets.Search(stub, query, \"\", true) if err != nil { return nil, errors.WrapErrorWithStatus(err, \"error searching for book's author\", 500) } responseJSON, err := json.Marshal(response) if err != nil { return nil, errors.WrapErrorWithStatus(err, \"error marshaling response\", 500) } return responseJSON, nil }, } Only org1 and org2 can call this method. GET method for Rest Api. Argument authorName of type string is required. Argument limit of type number is optional. The transaction uses the Search function to query Book assets from the ledger, filtering by author . The definition of the UpdateBookTenant transaction is as follows: var UpdateBookTenant = tx.Transaction{ Tag: \"updateBookTenant\", Label: \"Update Book Tenant\", Description: \"Change the tenant of a book\", Method: \"PUT\", Callers: []string{`$org\\dMSP`}, // Any orgs can call this transaction Args: []tx.Argument{ { Tag: \"book\", Label: \"Book\", Description: \"Book\", DataType: \"->book\", Required: true, }, { Tag: \"tenant\", Label: \"tenant\", Description: \"New tenant of the book\", DataType: \"->person\", }, }, Routine: func(stub *sw.StubWrapper, req map[string]interface{}) ([]byte, errors.ICCError) { bookKey, ok := req[\"book\"].(assets.Key) if !ok { return nil, errors.WrapError(nil, \"Parameter book must be an asset\") } tenantKey, ok := req[\"tenant\"].(assets.Key) if !ok { return nil, errors.WrapError(nil, \"Parameter tenant must be an asset\") } // Returns Book from channel bookAsset, err := bookKey.Get(stub) if err != nil { return nil, errors.WrapError(err, \"failed to get asset from the ledger\") } bookMap := (map[string]interface{})(*bookAsset) // Returns person from channel tenantAsset, err := tenantKey.Get(stub) if err != nil { return nil, errors.WrapError(err, \"failed to get asset from the ledger\") } tenantMap := (map[string]interface{})(*tenantAsset) updatedTenantKey := make(map[string]interface{}) updatedTenantKey[\"@assetType\"] = \"person\" updatedTenantKey[\"@key\"] = tenantMap[\"@key\"] // Update data bookMap[\"currentTenant\"] = updatedTenantKey bookMap, err = bookAsset.Update(stub, bookMap) if err != nil { return nil, errors.WrapError(err, \"failed to update asset\") } // Marshal asset back to JSON format bookJSON, nerr := json.Marshal(bookMap) if nerr != nil { return nil, errors.WrapError(err, \"failed to marshal response\") } return bookJSON, nil }, } Any organization that starts with \"org\" followed by a number (org1, org2, org3, org4, etc) can call this method. PUT method for Rest Api Argument book of type Book is mandatory. Argument person of type Person required. The transaction uses the Get function to read the the assets Book and Person information from the ledger The transaction uses the Update function to updates the asset information Book inside the ledger The definition of the GetNumberOfBooksFromLibrary transaction is as follows: var GetNumberOfBooksFromLibrary = tx.Transaction{ Tag: \"getNumberOfBooksFromLibrary\", Label: \"Get Number Of Books From Library\", Description: \"Return the number of books of a library\", Method: \"GET\", Callers: []string{\"$org2MSP\", \"$orgMSP\"}, // Only org2 can call this transactions Args: []tx.Argument{ { Tag: \"library\", Label: \"Library\", Description: \"Library\", DataType: \"->library\", Required: true, }, }, Routine: func(stub *sw.StubWrapper, req map[string]interface{}) ([]byte, errors.ICCError) { libraryKey, _ := req[\"library\"].(assets.Key) // Returns Library from channel libraryMap, err := libraryKey.GetMap(stub) if err != nil { return nil, errors.WrapError(err, \"failed to get asset from the ledger\") } numberOfBooks := 0 books, ok := libraryMap[\"books\"].([]interface{}) if ok { numberOfBooks = len(books) } returnMap := make(map[string]interface{}) returnMap[\"numberOfBooks\"] = numberOfBooks // Marshal asset back to JSON format returnJSON, nerr := json.Marshal(returnMap) if nerr != nil { return nil, errors.WrapError(err, \"failed to marshal response\") } return returnJSON, nil }, } Only org2 can call this method. GET method for Rest Api Argument library of type Library is required. The transaction uses the Get function to read Library asset information from the ledger","title":"Transaction examples"},{"location":"transactions/#transaction-list-definition","text":"The registration of the transactions that will be used by GoLedger CC-Tools library must be also done inside chaincode/txList.go file var txList = []tx.Transaction{ tx.CreateAsset, tx.UpdateAsset, tx.DeleteAsset, txdefs.CreateNewLibrary, txdefs.GetNumberOfBooksFromLibrary, txdefs.UpdateBookTenant, txdefs.GetBooksByAuthor, }","title":"Transaction list definition"},{"location":"transactions/#meta-inf","text":"Indexes allow a database to be queried without having to examine every row with every query, making them run faster and more efficiently. It's mandatory to create indexes for fields that will be used for sorted queries. The JSON index files must be located under the path META-INF/statedb/couchdb/indexes which is located inside the directory where the chaincode resides. For example: { \"index\":{ \"fields\":[ {\"published\": \"asc\"} ] }, \"ddoc\":\"indexListarBooksAscDoc\", \"name\":\"indexListarBooksAsc\", \"type\":\"json\" } See more on Create an index .","title":"META-INF"},{"location":"tutorials/","text":"Tutorials Writing Your First Application This tutorial will show how to install and use a smart contract (chaincode). You must already have configured the environment to be able to perform this tutorial. Details on Getting Started We'll see how the GoLedger CC-Tools library works, using the artifacts provided by GoLedger CCAPI integration Hyperledger Fabric Update API Development web application (cc-web) The cc-tools-demo repository smart contract is ideal for beginners to Hyperledger Fabric technology development. It's a great starting point to understand a Hyperledger Fabric blockchain and ease the journey of application development using this framework. You'll learn how to write an application and a smart contract (chaincode) to query and update a ledger, and how to connect to the Blockchain through a ready-to-use API. NOTE You need to know GoLang programming language in order to complete this tutorial. Network Details The standard network to be created will have the following configuration: 1 chaincode (cc-tools-demo) 3 orgs (org1, org2, org3) 3 clients (rest servers for org1, org2 and org3) There is also an option to create a smaller network with fewer entities, with the following configuration: 1 chaincode (cc-tools-demo) 1 org (org) 1 client (rest server for org) Chaincode Details The chaincode provided in cc-tools-demo has the following characteristics: 3 assets 1 private data 4 transactions Vendoring Both the chaincode and the CCAPI , in Golang, need to be vendored (dependency packages download) in order to properly work. To download chaincode dependencies, run the following script: cd chaincode && \\ go mod vendor && \\ cd .. To download the CCAPI dependencies, run the following script: cd ccapi && \\ go mod vendor && \\ cd .. Building your GoLedger CC-Tools network After installing the environment and vendoring the packages, the network is ready to be instantiated. This process takes place with the following script ./startDev.sh This script will perform the following tasks: Clear unused docker images and volumes Generate the MSP certificates for each org (visit the Hyperledger Fabric Docs to learn more). Create the Blockchain node containers ( Hyperledger Fabric peers and orderers) for 3 orgs (org1, org2, org3) with the correct cryptographic configuration for each one of them. Create the ledger for registration and permission - Hyperledger Fabric Channel Organizations entries in the channel (Join process in Hyperledger Fabric ) Chaincode installation inside endorsing peers Installation of network management api Hyperledger Fabric Chaincode instantiation on the channel Rest servers containers deployment with the correct cryptographic configuration, representing a Hyperledger Fabric Client for each organization. At the end of the process, the following messages should be displayed: Chaincode definition committed on channel 'mainchannel' ... Query chaincode definition successful on peer0.org1 on channel 'mainchannel' ... Query chaincode definition successful on peer0.org2 on channel 'mainchannel' ... Query chaincode definition successful on peer0.org3 on channel 'mainchannel' Chaincode initialization is not required [+] Running 3/3 \u283f Container ccapi.org2.example.com Started 0.3s \u283f Container ccapi.org1.example.com Started 0.5s \u283f Container ccapi.org3.example.com Started 0.5s The ccapi containers represent the rest servers for each organization. They may take a few minutes to come online. At the end, the following message should appear: docker logs ccapi.org1.example.com 2023/07/27 14:00:53 Listening on port 80 2023/07/27 14:00:53 sdk created from './config/configsdk-org1.yaml' 2023/07/27 14:00:53 sdk created from './config/configsdk-org1.yaml' Listening on port 80 To instantiate the minimal network using only one organization, use the following command: ./startDev.sh -n 1 Upgrading your chaincode Upgrading a smart contract can be done easily in chaincodes that use the GoLedger CC-Tools library. First, you must check the syntax of the modified code. cd chaincode \\ go vet \\ cd .. After validation, the chaincode update is done with the upgradeCC.sh script, which takes the chaincode version and sequence as arguments. NOTE A chaincode must always be updated with a version different from all previous versions and the sequence should be sequential from the one before. Example: ./upgradeCC.sh 0.2 2 Or if you are using the minimal network: ./upgradeCC.sh 0.2 2 -n 1 Reloading CCAPI If any changes were made to the CCAPI code you must reload it for the changes to take effect. First, check the syntax of the modified code. cd ccapi \\ go vet \\ cd .. After validation, the reloadCCAPI.sh script can be used to reload the rest server. ./reloadCCAPI.sh Or if you are using the minimal network: ./reloadCCAPI.sh -n 1 Renaming your project After testing cc-tools-demo and instantiating your first fabric network, you are ready to start developing your first chaincode. To use your own project name, instead of cc-tools-demo , the renameProject.sh script is availiable to rename all mentions to it on the project folder. The script takes the new name as an argument. Example: ./renameProject.sh my-first-chaincode","title":"Tutorials"},{"location":"tutorials/#tutorials","text":"","title":"Tutorials"},{"location":"tutorials/#writing-your-first-application","text":"This tutorial will show how to install and use a smart contract (chaincode). You must already have configured the environment to be able to perform this tutorial. Details on Getting Started We'll see how the GoLedger CC-Tools library works, using the artifacts provided by GoLedger CCAPI integration Hyperledger Fabric Update API Development web application (cc-web) The cc-tools-demo repository smart contract is ideal for beginners to Hyperledger Fabric technology development. It's a great starting point to understand a Hyperledger Fabric blockchain and ease the journey of application development using this framework. You'll learn how to write an application and a smart contract (chaincode) to query and update a ledger, and how to connect to the Blockchain through a ready-to-use API. NOTE You need to know GoLang programming language in order to complete this tutorial.","title":"Writing Your First Application"},{"location":"tutorials/#network-details","text":"The standard network to be created will have the following configuration: 1 chaincode (cc-tools-demo) 3 orgs (org1, org2, org3) 3 clients (rest servers for org1, org2 and org3) There is also an option to create a smaller network with fewer entities, with the following configuration: 1 chaincode (cc-tools-demo) 1 org (org) 1 client (rest server for org)","title":"Network Details"},{"location":"tutorials/#chaincode-details","text":"The chaincode provided in cc-tools-demo has the following characteristics: 3 assets 1 private data 4 transactions","title":"Chaincode Details"},{"location":"tutorials/#vendoring","text":"Both the chaincode and the CCAPI , in Golang, need to be vendored (dependency packages download) in order to properly work. To download chaincode dependencies, run the following script: cd chaincode && \\ go mod vendor && \\ cd .. To download the CCAPI dependencies, run the following script: cd ccapi && \\ go mod vendor && \\ cd ..","title":"Vendoring"},{"location":"tutorials/#building-your-goledger-cc-tools-network","text":"After installing the environment and vendoring the packages, the network is ready to be instantiated. This process takes place with the following script ./startDev.sh This script will perform the following tasks: Clear unused docker images and volumes Generate the MSP certificates for each org (visit the Hyperledger Fabric Docs to learn more). Create the Blockchain node containers ( Hyperledger Fabric peers and orderers) for 3 orgs (org1, org2, org3) with the correct cryptographic configuration for each one of them. Create the ledger for registration and permission - Hyperledger Fabric Channel Organizations entries in the channel (Join process in Hyperledger Fabric ) Chaincode installation inside endorsing peers Installation of network management api Hyperledger Fabric Chaincode instantiation on the channel Rest servers containers deployment with the correct cryptographic configuration, representing a Hyperledger Fabric Client for each organization. At the end of the process, the following messages should be displayed: Chaincode definition committed on channel 'mainchannel' ... Query chaincode definition successful on peer0.org1 on channel 'mainchannel' ... Query chaincode definition successful on peer0.org2 on channel 'mainchannel' ... Query chaincode definition successful on peer0.org3 on channel 'mainchannel' Chaincode initialization is not required [+] Running 3/3 \u283f Container ccapi.org2.example.com Started 0.3s \u283f Container ccapi.org1.example.com Started 0.5s \u283f Container ccapi.org3.example.com Started 0.5s The ccapi containers represent the rest servers for each organization. They may take a few minutes to come online. At the end, the following message should appear: docker logs ccapi.org1.example.com 2023/07/27 14:00:53 Listening on port 80 2023/07/27 14:00:53 sdk created from './config/configsdk-org1.yaml' 2023/07/27 14:00:53 sdk created from './config/configsdk-org1.yaml' Listening on port 80 To instantiate the minimal network using only one organization, use the following command: ./startDev.sh -n 1","title":"Building your GoLedger CC-Tools network"},{"location":"tutorials/#upgrading-your-chaincode","text":"Upgrading a smart contract can be done easily in chaincodes that use the GoLedger CC-Tools library. First, you must check the syntax of the modified code. cd chaincode \\ go vet \\ cd .. After validation, the chaincode update is done with the upgradeCC.sh script, which takes the chaincode version and sequence as arguments. NOTE A chaincode must always be updated with a version different from all previous versions and the sequence should be sequential from the one before. Example: ./upgradeCC.sh 0.2 2 Or if you are using the minimal network: ./upgradeCC.sh 0.2 2 -n 1","title":"Upgrading your chaincode"},{"location":"tutorials/#reloading-ccapi","text":"If any changes were made to the CCAPI code you must reload it for the changes to take effect. First, check the syntax of the modified code. cd ccapi \\ go vet \\ cd .. After validation, the reloadCCAPI.sh script can be used to reload the rest server. ./reloadCCAPI.sh Or if you are using the minimal network: ./reloadCCAPI.sh -n 1","title":"Reloading CCAPI"},{"location":"tutorials/#renaming-your-project","text":"After testing cc-tools-demo and instantiating your first fabric network, you are ready to start developing your first chaincode. To use your own project name, instead of cc-tools-demo , the renameProject.sh script is availiable to rename all mentions to it on the project folder. The script takes the new name as an argument. Example: ./renameProject.sh my-first-chaincode","title":"Renaming your project"}]}